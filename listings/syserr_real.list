	COMPILATION LISTING OF SEGMENT syserr_real
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1007.9 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 
       16 /****^  HISTORY COMMENTS:
       17*  1) change(89-08-28,Farley), approve(89-09-18,MCR8132),
       18*     audit(89-10-10,WAAnderson), install(89-10-11,MR12.3-1091):
       19*     Increased the size of the console output buffer (out_buf) from
       20*     132 to 256 to be consistent with oc_trans_output_.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 
       24 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       25 syserr_real:
       26      procedure (arg_code);
       27 
       28 /*	This procedure completely recoded  June 28, 1973 by  Bill Silver. */
       29 /* 	Modified 750227 by LJS to change max length of syserr messages */
       30 /*	Modified August, 1975 by Larry Johnson to implement error_code and binary entries */
       31 /*	Modified January 1976 by Larry Johnson to fix bugs in "=" message handling */
       32 /*	Modified March 1976 by Steve Webber to use logger HPROC */
       33 /*	Modified May 1976 by Larry Johnson to add "binary_mylock" entry for use by ocdcm_ */
       34 /*	Modified November 1976 by Larry Johnson to stop logging "=" messages */
       35 /*	Modified May 1977 by Noel I. Morris to shrink stack frame and implement panic */
       36 /*	Modified August 1977 by Noel I. Morris to fix bug in *lost "=" messages */
       37 /*	Modified August 1978 by Bernard S. Greenberg to eliminate calling ocdcm with syserr lock locked. */
       38 /*	Modified April 1982 by C. Hornig to add NL to console messages. */
       39 /*	Modified June 1982 by E. N. Kittlitz to not equalize alarm messages. */
       40 /*   	Modified September 1982 by C. Hornig to use automatic buffer for console */
       41 /*        Modified 830601 BIM to check for silly error codes. */
       42 /* 	Modified 830622 for new ocdcm_ interface... -E. A. Ranzenbach */
       43 /*        Modified 83-12-19 BIM for better call to terminate_proc */
       44 /*	Modified 83-??-?? Keith Loepere for calls to bce. */
       45 /*        Modified 1984-11-26, BIM: options (validate) changed to
       46*	pmut$wire_and_mask, actually call the copy primitive if
       47*	we are called unwired. */
       48 /*	Modified 1984-12-20, BIM: avoid recursive copy attempts by checking
       49*	the paged syserr log lock before actually copying. */
       50 /*	Modified 1984-12-21, EJ Sharpe for multiple_binary entrypoint */
       51 /*	Modified 1985-01-21, EJ Sharpe for 2047 char text (was 512),
       52*	also added process_id to wired msg */
       53 /*	Modified 1985-01-25, Keith Loepere, to fix race in log copying. */
       54 /*	Modified 1985-02-15, Keith Loepere, to restructure syserr paged vs
       55*	wired lock startegy; basically to make the paged lock the 
       56*	highest paged lock in the system so that a copy into the paged lock 
       57*	is always possible from any paged process. */
       58 /*	Modified 1985-03-28, EJ Sharpe, avoid copy to paged log when process
       59*	is to be terminated or system is to be crashed. */
       60 
       61 /*	The syserr code which we receive as an argument is converted
       62*   to an action code whose value is mod 10 of the original value.
       63*   The meaning of the ten possible action codes is:
       64*   0  =>  write message without alarm, log, and return.
       65*   1  =>  write message with alarm, log, and CRASH system - allow bce to return.
       66*   2  =>  write message with alarm, log, and terminate process.
       67*   3  =>  write message with alarm, log, and return.
       68*   4  =>  log message and return, don't write message unless message not logged.
       69*   5  =>  log message and return, don't write message even if not logged.
       70*   (6 - 9) not used, mapped into code 5.
       71*
       72*
       73*   /*		PARAMETER DATA		*/
       74 
       75 dcl  arg_code			fixed bin;	/* (I) The syserr code. */
       76 dcl  arg_data_code			fixed bin;	/* (I) Format of binary data on $binary entry */
       77 dcl  arg_data_len			fixed bin;	/* (I) Length of binary data on $binary entry */
       78 dcl  arg_data_pieces_array_ptr	ptr;		/* ptr to array of ptrs and lengths of bin data */
       79 dcl  arg_data_ptr			ptr;		/* (I) Pointer to binary data on $binary entry */
       80 dcl  arg_error_code			ptr unal;		/* (I) error_table_$ code on $error_code entry */
       81 dcl  arg_n_data_pieces		fixed bin;	/* number of pieces of bin data */
       82 dcl  arg_panic_mess			char (*);		/* (I) message to panic entry */
       83 
       84 
       85 /*		AUTOMATIC  DATA		*/
       86 
       87 dcl  alarm_flag			bit (1) aligned;	/* ON => write message with alarm.  */
       88 dcl  arg_list_ptr			ptr;		/* arg list to syserr_real */
       89 dcl  1 auto_mbuf			aligned,		/* refer to DATA STRUCTURING below */
       90        2 header			like mbuf_header,
       91        2 equal			char (4) unal;
       92 dcl  1 auto_wlog_header		aligned like wlog_header;
       93 dcl  1 auto_wmess_header		aligned like wmess_header;
       94 dcl  binary_call			bit (1);		/* ON => entered through $binary entry */
       95 dcl  code				fixed bin;	/* copy of code passed to syserr */
       96 dcl  cont_flag			bit (1) aligned;	/* Continuation line flag used by oc_trans_output_. */
       97 dcl  copying_permitted		bit (1) aligned;	/* environment permits page faults */
       98 dcl  cs_pos			fixed bin;	/* Position of ioa_ ccntrol string in param list */
       99 dcl  data_code			fixed bin;	/* Data classification code */
      100 dcl  data_len			fixed bin;	/* Length of binary data */
      101 dcl  data_piece_len			fixed bin;	/* Length of piece of binary data */
      102 dcl  data_piece_ptr			ptr;		/* Pointer to piece of binary data */
      103 dcl  data_pieces_array_ptr		pointer;		/* pointer to array of ptrs and lengths of the pieces of the binary data */
      104 dcl  data_ptr			ptr;		/* Pointer to binary data */
      105 dcl  error_table_call		bit (1);		/* ON => entered through $error_code entry */
      106 dcl  error_table_code		fixed bin (35);
      107 dcl  etmsgp			ptr;		/* Pointer to error table message on $error_code call */
      108 dcl  mbuf_ptr			ptr;		/* Pointer to ASCII message buffer. */
      109 dcl  message_len			fixed bin (21);	/* length of syserr message in data */
      110 dcl  n_data_pieces			fixed bin;	/* number of binary data parts */
      111 dcl  nargs			fixed bin;
      112 dcl  1 oc_io			aligned like console_io;
      113 dcl  oc_line_leng			fixed bin;	/* line length of the console...	*/
      114 dcl  oc_printed_leng		fixed bin;	/* how much we will print on console */
      115 dcl  ocdcm_code			fixed bin (35);	/* returned by ocdcm_...		*/
      116 dcl  old_mask			bit (72) aligned;	/* actually entry value of the mask */
      117 dcl  old_wlog_ptr			ptr;		/* to copy of syserr_data$wired_log_area */
      118 dcl  olen				fixed bin (19);	/* Length  of the output string in  WORDS.  */
      119 dcl  optr				ptr;		/* Pointer to beginning of the output buffer. */
      120 dcl  out_buf			char (256) aligned; /* console buffer */
      121 dcl  piece_index			fixed bin;	/* index of binary data piece */
      122 dcl  print_len			fixed bin (21);	/* number of chars to print on console */
      123 dcl  print_ptr			ptr;		/* Pointer to beginning of expanded message for console */
      124 dcl  print_this_line_len		fixed bin (21);	/* Number  of characters processed. */
      125 dcl  rtime			fixed bin (71);	/* Raw time in microseconds. */
      126 dcl  sys_code			fixed bin;	/* Syserr code of this message. */
      127 dcl  tenths_min			fixed bin;	/* Number of tenths of a minute. */
      128 dcl  wire_arg			bit (72) aligned;	/* mask with pmut's nasty note or'ed into it */
      129 dcl  wired			bit (1) aligned;	/* wired and masked */
      130 dcl  wired_wlog_ptr			ptr;		/* to syserr_data$wired_log_area */
      131 dcl  wired_wmess_ptr		ptr;		/* to where we would add message to syserr_data */
      132 dcl  wired_stack_ptr		pointer;		/* restore value for unwire_unmask */
      133 dcl  wmess_len			fixed bin;	/* Size of current wired message entry. */
      134 dcl  write_flag			bit (1) aligned;	/* ON => this message should be written. */
      135 
      136 
      137 /*		BASED  DATA		*/
      138 
      139 dcl  CR_NL			char (5) based (addr (CR_NL_bits));
      140 
      141 /* DATA STRUCTURING:
      142*     This program endeavors to avoid copying data many times.  As such,
      143*it overlays various data structures such that the large data areas need be
      144*copied as seldom as possible.  The idea is to build a wlog structure that
      145*is acceptable to syserr_copy$wired_log.  However, the text in this wlog 
      146*structure also wants to be part of a mbuf structure for console purposes.
      147*So, we lay down the text and data as for a wlog structure, but not the
      148*header.  Instead, we allow for enough room for either a wlog/wmess header,
      149*or a mbuf header, but keep these headers in auto storage, and overlay them
      150*in front of the text when necessary. */
      151 
      152 dcl  binary_data			(data_len) bit (36) aligned based (data_ptr); /* binary data on $binary entry */
      153 dcl  data_piece			(data_piece_len) bit (36) aligned based (data_piece_ptr); /* Binary data on $multiple_binary entry */
      154 
      155 dcl  1 data_pieces_array		(n_data_pieces) aligned based (data_pieces_array_ptr),
      156 						/* an array of pointers pieces of the binary data */
      157        2 ptr			pointer,		/* pointer to part of the binary data */
      158        2 len			fixed bin;	/* number of words */
      159 
      160 dcl  1 et				aligned based (etmsgp), /* An error table message */
      161        2 len			fixed bin (8) unal, /* Length of the message */
      162        2 msg			char (et.len) unal; /* The message */
      163 
      164 /* This buffer will hold the ASCII message.  When writing a message the string will
      165*   start at either  mbuf.no_log or mbuf.time  and extend to and include mbuf.text. */
      166 
      167 dcl  1 mbuf			aligned based (mbuf_ptr),
      168        2 header			aligned like mbuf_header,
      169        2 text			char (2047) unal;	/* Expanded syserr message in ASCII. */
      170 
      171 dcl  1 mbuf_header			aligned based,
      172        2 no_log,					/* Special message written only if there is no room
      173*						   in the wired log buffer for this message entry. */
      174          3 lost			char (6) unal,	/* "*lost " */
      175          3 seq_num			pic "9999" unal,
      176          3 comma			char (2) unal,	/* ", " */
      177          3 sys_code			pic "9" unal,
      178          3 pad			char (3) unal,
      179        2 time,					/* Time message logged.  Converted to:  "hhmm.t"
      180*						   where t = tenths of minutes. */
      181          3 hh			pic "99" unal,
      182          3 mmt			pic "99.9" unal,
      183          3 pad			char (2) unal;
      184 
      185 dcl  old_wlog			(syserr_data$wired_log_size) bit (36) aligned based (old_wlog_ptr);
      186 						/* allocated copy of syserr_data$wired_log_area */
      187 
      188 dcl  wmess_copy			(wmess_len) bit (36) aligned based; /* for copying wmess into syserr_data */
      189 
      190 
      191 /*		EXTERNAL ENTRIES CALLED	*/
      192 
      193 dcl  arg_count_			entry (fixed bin);
      194 dcl  arg_list_ptr_			entry (ptr);
      195 dcl  formline_			entry (fixed bin, fixed bin, ptr, fixed bin (21), fixed bin, ptr);
      196 dcl  oc_trans_output_		entry (ptr, fixed bin (21), fixed bin (21), ptr, fixed bin (19), fixed bin, bit (1) aligned);
      197 dcl  ocdcm_$console_info		entry (char (4), bit (36), char (8), fixed bin, fixed bin, fixed bin (35));
      198 dcl  ocdcm_$drain_io		entry ();
      199 dcl  ocdcm_$priority_io		entry (ptr);
      200 dcl  pmut$bce_and_return		entry options (variable);
      201 dcl  pmut$read_mask			entry (bit (72) aligned);
      202 dcl  pmut$set_mask			entry (bit (72) aligned);
      203 dcl  pmut$unwire_unmask		entry (bit (72) aligned, pointer);
      204 dcl  pmut$wire_and_mask		entry (bit (72) aligned, pointer);
      205 dcl  pxss$unique_ring_0_wakeup	entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
      206 dcl  syserr			entry options (variable);
      207 dcl  syserr_copy$lock		entry ();
      208 dcl  syserr_copy$unlock		entry ();
      209 dcl  syserr_copy$wired_log		entry (ptr);
      210 dcl  syserr_real$syserr_real		entry options (variable);
      211 dcl  terminate_proc			entry (fixed bin (35));
      212 dcl  wired_utility_$grow_stack_frame	entry (fixed bin) returns (ptr);
      213 
      214 
      215 /*		EXTERNAL DATA	 */
      216 
      217 dcl  error_table_$			ext;
      218 dcl  pds$process_group_id		char (32) aligned ext;
      219 dcl  pds$processid			bit (36) aligned ext;
      220 dcl  pds$apt_ptr			pointer ext;
      221 dcl  prds$			ext;
      222 dcl  prds$idle_ptr			pointer ext;
      223 dcl  scs$open_level			bit (72) aligned ext;
      224 dcl  sys_info$time_correction_constant	fixed bin (71) ext;
      225 dcl  syserr_data$logger_ec		fixed bin (71) ext;
      226 dcl  syserr_data$logger_proc_id	bit (36) aligned ext;
      227 dcl  syserr_data$wired_log_size	fixed bin ext;
      228 
      229 
      230 /*		MISCELANEOUS	*/
      231 
      232 dcl  cleanup			condition;
      233 
      234 dcl  (add, addcharno, addr, addrel, baseno, bin, bit, byte, clock, currentsize, divide, length, max, min, mod, multiply, ptr, rel, rtrim, segno, size, stac, stackbaseptr, stacq, string, substr, unspec, wordno) builtin;
      235 
      236 
      237 /*		CONSTANTS		*/
      238 
      239 dcl  CR_NL_bits			bit (45) static options (constant) init ("015012177177177"b3); /* cr, nl, 3 pads - 
      240*					sufficient to add nl to console string */
      241 dcl  bad_ring1_msg			char (24) static options (constant) init ("syserr: Bad ring 1 call.");
      242 dcl  crash_msg			char (46) static options (constant) init ("Multics not in operation; control process: ^a.");
      243 dcl  lock_msg			char (21) static options (constant) init ("syserr: Mylock error.");
      244 dcl  terminate_msg			char (33) static options (constant) init ("Now terminating user process: ^a.");
      245 
      246 
      247 /*	MAIN  SYSERR_REAL  ENTRY  -  CALLED BY  SYSERR */
      248 
      249 	cs_pos = 2;				/* formline_ control string is second param */
      250 	call ring0_setup;
      251 
      252 syserr_start:
      253 	data_len = 0;
      254 
      255 	call arg_list_ptr_ (arg_list_ptr);
      256 	call SETUP_AND_TEXT;
      257 	go to COMMON;
      258 
      259 
      260 /* Entry point if binary data is included */
      261 
      262 binary:
      263      entry (arg_code, arg_data_ptr, arg_data_code, arg_data_len);
      264 
      265 	cs_pos = 5;				/* formline_ control string is 5th param */
      266 	call ring0_setup;
      267 
      268 syserr_binary_start:
      269 	data_len = arg_data_len;
      270 
      271 	call arg_list_ptr_ (arg_list_ptr);
      272 	call SETUP_AND_TEXT;
      273 	if data_len > 0 then do;			/* If there is binary data */
      274 	     binary_call = "1"b;			/* this is binary call */
      275 	     data_code = arg_data_code;
      276 	     data_ptr -> binary_data = arg_data_ptr -> binary_data; /* Copy to wired stack */
      277 	end;
      278 
      279 	go to COMMON;
      280 
      281 
      282 /* Entry point if binary data is supplied in pieces */
      283 
      284 multiple_binary:
      285      entry (arg_code, arg_data_pieces_array_ptr, arg_n_data_pieces, arg_data_code);
      286 
      287 	cs_pos = 5;
      288 	call ring0_setup;
      289 
      290 syserr_multiple_binary_start:
      291 	data_pieces_array_ptr = arg_data_pieces_array_ptr;
      292 	n_data_pieces = arg_n_data_pieces;
      293 	data_len = 0;
      294 	do piece_index = 1 to n_data_pieces;
      295 	     data_len = data_len + data_pieces_array (piece_index).len;
      296 	end;
      297 
      298 	call arg_list_ptr_ (arg_list_ptr);
      299 	call SETUP_AND_TEXT;
      300 
      301 	if data_len > 0 then do;
      302 	     binary_call = "1"b;			/* there's something for us */
      303 	     data_code = arg_data_code;
      304 	     data_piece_ptr = data_ptr;
      305 	     do piece_index = 1 to n_data_pieces;	/* copy it piece by piece */
      306 		data_piece_len = data_pieces_array (piece_index).len;
      307 		data_piece_ptr -> data_piece = data_pieces_array (piece_index).ptr -> data_piece;
      308 		data_piece_ptr = addrel (data_piece_ptr, data_piece_len);
      309 	     end;
      310 	end;
      311 	goto COMMON;
      312 
      313 
      314 /* Enter here with error code to expand */
      315 
      316 error_code:
      317      entry (arg_code, arg_error_code);
      318 
      319 	cs_pos = 3;				/* formline_ control string is 3rd */
      320 	call ring0_setup;
      321 
      322 syserr_error_start:
      323 	error_table_call = "1"b;
      324 	data_len = 0;
      325 
      326 	call arg_list_ptr_ (arg_list_ptr);
      327 	call SETUP_AND_TEXT;
      328 	go to COMMON;
      329 
      330 
      331 /* Ring 1 entry points to syserr. These entries are the same as the corresponding ring 0
      332*   entries, except that a ring 1 caller is not allowed to crash the system or terminate a process. */
      333 
      334 ring1:
      335      entry (arg_code);
      336 
      337 	cs_pos = 2;				/* control string is second */
      338 	call arg_count_ (nargs);			/* get argument count */
      339 	call ring1_setup;
      340 	go to syserr_start;				/* normal ring0 entry starts here */
      341 
      342 
      343 ring1_error_code:
      344      entry (arg_code, arg_error_code);
      345 
      346 	cs_pos = 3;				/* control string is 3rd  */
      347 	call arg_count_ (nargs);			/* get argument count */
      348 	call ring1_setup;
      349 	go to syserr_error_start;			/* ring0 entry starts here */
      350 
      351 
      352 ring1_binary:
      353      entry (arg_code, arg_data_ptr, arg_data_code, arg_data_len);
      354 
      355 	cs_pos = 5;				/* control string is 5th */
      356 	call arg_count_ (nargs);			/* get argument count */
      357 	call ring1_setup;
      358 	go to syserr_binary_start;
      359 
      360 
      361 ring1_multiple_binary:
      362      entry (arg_code, arg_data_pieces_array_ptr, arg_n_data_pieces, arg_data_code);
      363 	cs_pos = 5;
      364 	call arg_count_ (nargs);			/* get argument count */
      365 	call ring1_setup;
      366 	goto syserr_multiple_binary_start;
      367 
      368 COMMON:
      369 	wired = "0"b;
      370 	on cleanup
      371 	     begin;				/* locks will be unlocked by verify_lock */
      372 	     if wired then call pmut$unwire_unmask (wire_arg, wired_stack_ptr);
      373 	end;
      374 	copying_permitted = "0"b;
      375 
      376 	sd_ptr = addr (syserr_data$syserr_area);
      377 
      378 	call pmut$read_mask (old_mask);
      379 	if old_mask = scs$open_level then		/* allowing interrupts */
      380 	     if pds$apt_ptr ^= prds$idle_ptr then	/* Not an idle process */
      381 		if stackbaseptr () ^= addr (prds$) then /* Not on the PRDS */
      382 		     if ^termp_flags (sys_code)
      383 			& ^crash_flags (sys_code) then/* not if process/system will disappear */
      384 			if sd.log_flag then		/* WARNING, this is a paged database. */
      385 						/* The following tree touches it IFF all the other conditions are satisfied. */
      386 			     if addr (syserr_log_data$) -> syserr_log_data.lock.pid ^= pds$processid then
      387 						/* Not in the middle of copying the log already */
      388 				copying_permitted = "1"b; /* All these pass? then we can copy here. */
      389 
      390 	write_flag = write_flags (sys_code);		/* Set flag if message is to be written */
      391 	alarm_flag = alarm_flags (sys_code);		/* set flag if alarm needed */
      392 
      393 	rtime = clock ();				/* Get raw time in microseconds. */
      394 
      395 	auto_wmess_header.code = code;		/* fill in wmess header that we can unwired */
      396 	auto_wmess_header.time = rtime;
      397 	auto_wmess_header.pad = "0"b;
      398 	auto_wmess_header.process_id = pds$processid;
      399 	auto_wmess_header.data_code = data_code;
      400 
      401 	wired_wlog_ptr = addr (syserr_data$wired_log_area);
      402 						/* place for old messages */
      403 	if copying_permitted then do;			/* when we can copy, we get and hold the paged lock.
      404*						   The wired area is emptied into the paged log, and then we add
      405*						   our message to the paged log.  Our message never goes into the
      406*						   wired area. */
      407 	     call syserr_copy$lock ();
      408 	     old_wlog_ptr = wired_utility_$grow_stack_frame (syserr_data$wired_log_size);
      409 	end;
      410 
      411 	call pmut$wire_and_mask (wire_arg, wired_stack_ptr);
      412 	wired = "1"b;
      413 
      414 /* Before we reference any data in syserr_data we may have to lock it.
      415*   Note, this lock controls all the data in syserr_data including the wired_log_area. */
      416 
      417 	if ^sd.ocdcm_init_flag then call panic (mbuf.text);
      418 
      419 	call SR_LOCK ();
      420 
      421 /* Now fill in the time of message string that goes before each message.
      422*   It is in the form:  "hhmm.t  ". */
      423 
      424 	print_ptr = addr (mbuf.time);			/* For now, console message starts with time. */
      425 	print_len = message_len + length (string (mbuf.time)); /* Get total length of string being written. */
      426 
      427 	tenths_min = mod (divide (rtime - sys_info$time_correction_constant, 6000000, 52, 0), 14400);
      428 						/* Number of 10ths of minutes so far today */
      429 	auto_mbuf.header.time.hh = divide (tenths_min, 600, 5);
      430 	auto_mbuf.header.time.mmt = tenths_min - divide (tenths_min, 600, 5) * 600;
      431 	auto_mbuf.header.time.pad = "";
      432 
      433 	if ^sd.log_flag then			/* Is logging mechanism ON? */
      434 						/* NO, can't log message. */
      435 	     auto_wmess_header.seq_num = 0;		/* Thus there is no sequence number. */
      436 	else if copying_permitted then do;
      437 
      438 /* look for old messages to copy out */
      439 
      440 	     if wired_wlog_ptr -> wlog.count > 0 then do;
      441 		old_wlog_ptr -> old_wlog = wired_wlog_ptr -> old_wlog; /* copy out old messages */
      442 		wired_wlog_ptr -> wlog.next = rel (addr (wired_wlog_ptr -> wlog.buffer)); /* reset wired log */
      443 		wired_wlog_ptr -> wlog.count = 0;
      444 	     end;
      445 	     else old_wlog_ptr -> wlog.count = 0;	/* no old messages */
      446 
      447 	     auto_wmess_header.seq_num, wired_wlog_ptr -> wlog.seq_num = wired_wlog_ptr -> wlog.seq_num + 1;
      448 	end;
      449 
      450 
      451 /* This code is entered to put the current syserr message into the wired log.
      452*   Each time this procedure is called we want to wake up the syserr
      453*   logger HPROC who takes the messages out of the wired log buffer. */
      454 
      455 	else do;
      456 
      457 /* Get pointer to this message entry.  We have to fill in the length of the
      458*   text before we know where the end of the entry will be.  Assume for now that
      459*   there is room for this message. */
      460 
      461 	     wired_wmess_ptr = ptr (wired_wlog_ptr, wired_wlog_ptr -> wlog.next);
      462 
      463 RETRY_ADD:					/* here to retry with a shrunk message */
      464 
      465 /* Now check to see if there really is room for this message entry in the wired buffer.
      466*   If not, we will have to write out the message with a special prefix:
      467*   "*lost xxxxxx, z "
      468*   where	 xxxxxx  is the sequence number of the message, and
      469*   z       is the syserr code of the message. */
      470 
      471 	     if wmess_len > (size (wlog_header) + wired_wlog_ptr -> wlog.bsize)
      472 		- (bin (wired_wlog_ptr -> wlog.next, 18) - wordno (wired_wlog_ptr)) then do;
      473 						/* Is entry too big?  Do this if YES. */
      474 		if binary_call then do;		/* First try throwing away binary data */
      475 		     binary_call = "0"b;		/* by making it no longer a binary call */
      476 		     wmess_len = wmess_len - auto_wmess_header.data_size;
      477 		     auto_wmess_header.data_size = 0;
      478 		     go to RETRY_ADD;
      479 		end;
      480 
      481 		auto_wmess_header.seq_num,		/* Get sequence number of this message. */
      482 		     wired_wlog_ptr -> wlog.seq_num = wired_wlog_ptr -> wlog.seq_num + 1; /* claim sequence number now. */
      483 
      484 		if wifnl_flags (sys_code) then do;	/* If message should be written if not logged */
      485 		     write_flag = "1"b;		/* causes message to be written */
      486 		     print_ptr = addr (mbuf.no_log);	/* Now writing special note.  */
      487 		     print_len = print_len + length (string (mbuf.no_log));
      488 		     auto_mbuf.header.no_log.lost = "*lost"; /* initialize work area */
      489 		     auto_mbuf.header.no_log.comma = ",";
      490 		     auto_mbuf.header.no_log.pad = "";
      491 		     auto_mbuf.header.no_log.seq_num = mod (auto_wmess_header.seq_num, 10000);
      492 						/* edit sequence number */
      493 		     auto_mbuf.header.no_log.sys_code = sys_code; /* edit code */
      494 		end;
      495 	     end;
      496 	     else do;
      497 
      498 /* There is room for this message in the wired log.  Thus we can fill in the entry. */
      499 
      500 		auto_wmess_header.seq_num,		/* Get sequence number of this message. */
      501 		     wired_wlog_ptr -> wlog.seq_num = wired_wlog_ptr -> wlog.seq_num + 1; /* now that we know for sure that we are sending it. */
      502 
      503 		wired_wlog_ptr -> wlog.next = bit (add (bin (wired_wlog_ptr -> wlog.next, 18), wmess_len, 18), 18); /* Incr address of where next entry goes. */
      504 		wired_wlog_ptr -> wlog.count = wired_wlog_ptr -> wlog.count + 1; /* Add message to log buffer. */
      505 
      506 		wmess_ptr -> wmess.header = auto_wmess_header; /* construct wmess_header in front of message */
      507 		wired_wmess_ptr -> wmess_copy = wmess_ptr -> wmess_copy; /* add wmess to syserr_data */
      508 	     end;
      509 
      510 	     call WAKEUP_DAEMON;			/* move these messages! */
      511 	end;
      512 
      513 /* If we don't have to write this message then we are all done.  If we must write it then
      514*   we must first convert it for console output.   Note, a maximum of 80 characters can
      515*   be typed on one line.  With the "no_log" and "time" strings at the beginning of the
      516*   line and since ASCII characters may convert into more than one typed character, it is
      517*   possible the output string will be too long.  In this case the line will be
      518*   continued.  Note, the message itself may consist of more than one line. */
      519 
      520 	if write_flag then do;			/*  write - code is (4 - 9). */
      521 
      522 /* Check here for a non-alarm syserr message being the same as the last message written.
      523*   If this is the case, only an "=" will be printed. */
      524 
      525 	     if ^alarm_flag & mbuf.text = sd.prev_text_written then do;
      526 						/* A match */
      527 		print_len = print_len - message_len + 1;
      528 		message_len = 1;			/* set length to 1 character */
      529 		print_ptr = addrel (addr (auto_mbuf), wordno (print_ptr) - wordno (mbuf_ptr)); /* lie - tell ocdcm_ to print only this header */
      530 		if mbuf.text ^= " " then auto_mbuf.equal = "=";
      531 		else auto_mbuf.equal = "";
      532 						/* substitute "=" unless blank message */
      533 	     end;
      534 	     else do;				/* New message */
      535 		if message_len > length (sd.prev_text_written) then /* too long to save */
      536 		     unspec (sd.prev_text_written) = "0"b;
      537 						/* so clear out old message */
      538 		else sd.prev_text_written = substr (mbuf.text, 1, message_len);
      539 						/* save text */
      540 		mbuf_ptr -> mbuf_header = auto_mbuf.header; /* get the real mbuf header in front of the message for printing */
      541 	     end;
      542 	end;
      543 
      544 /* Syserr data has been globally updated.  Now we need to write the actual message, which is done from data in the stack. */
      545 
      546 	call SR_UNLOCK;				/* Unlock syserr data */
      547 
      548 	if write_flag then do;
      549 	     optr = addr (out_buf);			/* Pointer to output buffer. */
      550 	     cont_flag = "0"b;			/* => 1st line of message.  oc_trans_output_ turns
      551*						   it ON in case of a continuation line.  */
      552 
      553 /* Each iteration processes 1 console output line.
      554*   There may be more than one line in the syserr
      555*   message or there may be a continuation line. */
      556 
      557 
      558 	     call ocdcm_$console_info ("", "0"b, "", 0, oc_line_leng, ocdcm_code);
      559 						/* get console line length...		*/
      560 	     if ocdcm_code ^= 0 then oc_line_leng = 80;	/* default line length...		*/
      561 
      562 	     do while (print_len > 0);
      563 		call oc_trans_output_ (print_ptr, print_len, print_this_line_len, optr, olen, oc_line_leng, cont_flag);
      564 		oc_printed_leng = multiply (olen, 4, 17);
      565 
      566 		oc_io.read = "0"b;
      567 		oc_io.alert = alarm_flag;
      568 		oc_io.sequence_no = auto_wmess_header.seq_num;
      569 		oc_io.event_chan = 0;
      570 
      571 		if print_this_line_len >= print_len then do; /* this is the last line - add CR NL */
      572 		     oc_printed_leng = length (rtrim (substr (out_buf, 1, oc_printed_leng), byte (127))); /* actual last char */
      573 		     substr (out_buf, oc_printed_leng + 1, 5) = CR_NL;
      574 		     olen = divide (oc_printed_leng + 5, 4, 17); /* 2 for cr/nl, 3 for rounding up to word */
      575 		     oc_printed_leng = multiply (olen, 4, 17);
      576 		end;
      577 
      578 /* advance for next line */
      579 		print_ptr = addcharno (print_ptr, print_this_line_len);
      580 		print_len = print_len - print_this_line_len;
      581 		alarm_flag = "0"b;			/* Don't want alarm ON more than once. */
      582 
      583 		oc_io.leng = olen;
      584 		oc_io.text = substr (out_buf, 1, oc_printed_leng);
      585 
      586 		call ocdcm_$priority_io (addr (oc_io)); /* do the I/O...*/
      587 	     end;
      588 
      589 
      590 /*	Now check to see if we have to terminate the process or CRASH the system.  */
      591 
      592 	     if termp_flags (sys_code) then do;		/* If process to be terminated */
      593 		call syserr_real$syserr_real (LOG, terminate_msg, pds$process_group_id);
      594 		call pmut$set_mask (scs$open_level);	/* Unmask so that recursive call wires */
      595 		call terminate_proc (error_table_code);
      596 	     end;
      597 
      598 
      599 	     else if crash_flags (sys_code) then do;	/* If system is to crash */
      600 
      601 /* TOO BAD we must CRASH.  Before we call bce we must be sure that all of the messages on
      602*   the ocdcm_ syserr write queue have been written.  We will call a special entry
      603*   in  ocdcm_ which completes all pending I/O. */
      604 
      605 		call syserr_real$syserr_real (ANNOUNCE, crash_msg, pds$process_group_id);
      606 
      607 		call ocdcm_$drain_io ();		/* flush pending I/O...		*/
      608 
      609 		call pmut$bce_and_return;
      610 	     end;
      611 	end;
      612 
      613 
      614 /* Time to leave */
      615 
      616 	call pmut$unwire_unmask (wire_arg, wired_stack_ptr);
      617 
      618 	if copying_permitted then do;
      619 	     if old_wlog_ptr -> wlog.count > 0 then call syserr_copy$wired_log (old_wlog_ptr);
      620 	     wlog_ptr -> wlog_header = auto_wlog_header;	/* reconstruct wlog header before text */
      621 	     wlog.count = 1;
      622 	     wmess_ptr -> wmess_header = auto_wmess_header;
      623 	     call syserr_copy$wired_log (wlog_ptr);	/* add in our new message */
      624 	     call syserr_copy$unlock;
      625 	end;
      626 	return;
      627 
      628 /* All this entry does is force the  sd.lock  OFF.  */
      629 
      630 syserr_reset:
      631      entry;
      632 
      633 	addr (syserr_data$syserr_area) -> sd.lock = "0"b;
      634 
      635 	return;
      636 
      637 
      638 /* This entry is called if syserr is called before the IOM and operator's
      639*   console software has been initialized.  It is also called when trouble
      640*   is encountered in syserr or ocdcm_. */
      641 
      642 panic:
      643      entry (arg_panic_mess);
      644 
      645 	fgbxp = addr (flagbox$);			/* Get pointer to bce flagbox. */
      646 	fgbx.message = arg_panic_mess;		/* Copy the message. */
      647 	fgbx.alert, fgbx.mess = "1"b;			/* Turn on flag bits. */
      648 
      649 	do while ("1"b);				/* Back to bce. */
      650 	     call pmut$bce_and_return;
      651 	end;
      652 
      653 
      654 /* common processing for ring 1 calls */
      655 
      656 ring1_setup:
      657      proc;
      658 
      659 	binary_call = "0"b;				/* defaults */
      660 	data_code = 0;
      661 	error_table_call = "0"b;
      662 
      663 	if nargs < cs_pos then do;			/* if not enough */
      664 	     call syserr (4, bad_ring1_msg);
      665 	     go to ring1_return;
      666 	end;
      667 	code = arg_code;				/* copy the code */
      668 	sys_code = mod (code, 10);			/* compute action code */
      669 	code = divide (code, 10, 17, 0);		/* check sort code */
      670 	if code < 0 | code > 24 then code = 24;		/* apply default if out of range */
      671 	code = 10 * code + sys_code;			/* this is new code after errors removed */
      672 
      673      end ring1_setup;
      674 
      675 
      676 ring1_return:
      677 	return;					/* nonlocal return from ring1_setup */
      678 
      679 
      680 ring0_setup: proc;
      681 
      682 	binary_call = "0"b;				/* defaults */
      683 	data_code = 0;
      684 	error_table_call = "0"b;
      685 
      686 	code = arg_code;				/* copy syserr code */
      687 	sys_code = mod (code, 10);			/* compute action code */
      688 	return;
      689      end ring0_setup;
      690 
      691 
      692 /* This internal procedure is called to unlock the wired log.  */
      693 
      694 SR_UNLOCK:
      695      procedure;
      696 
      697 	if stacq (sd.lock, "0"b, sd.lock) then ;	/* Unlock unconditionally */
      698 
      699      end SR_UNLOCK;
      700 
      701 SR_LOCK:
      702      procedure;
      703 
      704 	if sd.lock = pds$processid then call panic (lock_msg);
      705 	do while (^stac (addr (sd.lock), pds$processid));
      706 	end;
      707 	return;
      708      end SR_LOCK;
      709 
      710 WAKEUP_DAEMON:
      711      procedure;
      712 
      713 	call pxss$unique_ring_0_wakeup (syserr_data$logger_proc_id, syserr_data$logger_ec, 0, (0));
      714 	return;
      715      end WAKEUP_DAEMON;
      716 
      717 SETUP_AND_TEXT:
      718      proc;
      719 
      720 /* allocate a wlog structure to hold our message;
      721*   generate the text of the message */
      722 
      723 dcl  len_for_et			fixed bin;
      724 dcl  max_header_size		fixed bin;
      725 dcl  text_and_data_size		fixed bin;
      726 dcl  work_ptr			ptr;
      727 
      728 	auto_wmess_header.text_len, message_len = 2047;	/* maximum */
      729 	auto_wmess_header.data_size = data_len;
      730 
      731 	text_and_data_size = currentsize (addr (auto_wmess_header) -> wmess); /* how much a wmess corresponding to this auto header would need */
      732 
      733 	max_header_size = max (size (wlog_header) + size (wmess_header), size (mbuf_header));
      734 
      735 	work_ptr = wired_utility_$grow_stack_frame (max_header_size + text_and_data_size); /* Allocate message buffer. */
      736 
      737 	wlog_ptr = addrel (work_ptr, max_header_size - (size (wlog_header) + size (wmess_header)));
      738 	wmess_ptr = addrel (wlog_ptr, size (wlog_header));
      739 	mbuf_ptr = addrel (work_ptr, max_header_size - size (mbuf_header));
      740 
      741 	call formline_ (cs_pos, cs_pos + 1, addr (wmess.text), message_len, 1, arg_list_ptr);
      742 						/* Expand syserr message. */
      743 
      744 	if message_len = 0 then do;			/* if asked to write null message, be careful */
      745 	     substr (wmess.text, 1, 4) = "";		/* clear text buffer */
      746 	     message_len = 1;			/* write 1 blank */
      747 	end;
      748 
      749 	error_table_code = -9;
      750 	if error_table_call then do;			/* If passed an error table code */
      751 	     etmsgp = arg_error_code;			/* Copy packed pointer. */
      752 	     unspec (error_table_code) = unspec (arg_error_code);
      753 	     if baseno (etmsgp) = "077777"b3 then	/* If segment is -1 ... */
      754 		etmsgp = ptr (addr (error_table_$), rel (etmsgp));
      755 						/* Use error_table_. */
      756 	     if segno (etmsgp) = 0 then error_table_code = -9;
      757 	     else do;
      758 		len_for_et = auto_wmess_header.text_len - message_len;
      759 						/* Amount of room left to insert message */
      760 		len_for_et = min (len_for_et, et.len + 1);
      761 		if len_for_et > 0 then do;
      762 		     substr (wmess.text, message_len + 1, 1) = " ";
      763 		     substr (wmess.text, message_len + 2, len_for_et - 1) = et.msg;
      764 						/* Concatenate message on end */
      765 		     message_len = message_len + len_for_et;
      766 						/* Adjust message length */
      767 		end;
      768 	     end;
      769 	end;
      770 
      771 	auto_wmess_header.text_len = message_len;
      772 	wmess_len = currentsize (addr (auto_wmess_header) -> wmess);
      773 	data_ptr = addrel (wmess_ptr, wmess_len - data_len);
      774 	return;
      775      end SETUP_AND_TEXT;
      776  /* BEGIN INCLUDE FILE ... flagbox.incl.pl1 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(87-02-26,Farley), approve(87-04-15,MCR7661),
  1     6*     audit(87-04-21,Fawcett), install(87-04-28,MR12.1-1028):
  1     7*     Added io_reconfig flag to inhibit BCE from attempting an emergency
  1     8*     shutdown when the data in memory could be corrupted.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* last modified 5/3/77 by Noel I. Morris	*/
  1    13 /* Modified 8/79 by R.J.C. Kissel to add FNP blast message. */
  1    14 /* Modified 7/82 BIM for recognizable sentinel field */
  1    15 /* Modified for bootload Multics flagbox starting in 8/83 by Keith Loepere. */
  1    16 
  1    17 /* The contents of this segment are data shared by Multics and bce.
  1    18*   This entity occupies the locations within the toehold starting at 40o
  1    19*   (not counting the toehold_used spacer at the beginning). */
  1    20 
  1    21 dcl  flagbox$ ext;
  1    22 dcl  fgbxp ptr;
  1    23 
  1    24 dcl 1 fgbx based (fgbxp) aligned,
  1    25     2 toehold_used (32) bit (36) aligned,		/* flagbox seg now mapped onto all of first page of toehold -
  1    26*						This is what was unused before. */
  1    27     2 flags (36) bit (1) unal,			/* communications switches */
  1    28     2 slt_segno bit (18),				/* segment # of the SLT */
  1    29     2 pad1 fixed bin,
  1    30     2 rtb,					/* return to bce info */
  1    31      (3 ssenb bit (1),				/* "1"b if storage system enabled */
  1    32       3 call_bce bit (1),				/* "1"b if bce called by operator */
  1    33       3 shut bit (1),				/* "1"b if bce called after shutdown */
  1    34       3 mess bit (1),				/* "1"b if message has been provided */
  1    35       3 alert bit (1),				/* "1"b if audible alarm to be sounded */
  1    36       3 breakpoint bit (1),				/* "1"b is breakpoint caused call to bce */
  1    37       3 manual_crash bit (1),				/* either manual entry or execute fault */
  1    38       3 io_reconfig bit (1),				/* "1"b if I/O reconfiguration */
  1    39 						/* could cause memory corruption */
  1    40       3 pad bit (21),
  1    41       3 bce_entry fixed bin (6) uns) unal,		/* type of entry into bce
  1    42*						   00o => Multics entry
  1    43*						   20o => manual entry
  1    44*						   40o => esd entry */
  1    45     2 sentinel char (32) aligned,			/* set by bce (for now) */
  1    46     2 sst_sdw bit (72),				/* set by init_sst */
  1    47     2 hc_dbr bit (72),				/* set by start_cpu, idle DBR */
  1    48     2 message char (64),				/* message for return to bce */
  1    49     2 return_to_bce_command char (128) unal;		/* command to run upon crash/shutdown */
  1    50 
  1    51 declare FLAGBOX_SENTINEL char (32) init ("Flagbox & Toehold Valid") int static options (constant);
  1    52 
  1    53 /* END INCLUDE FILE ... flagbox.incl.pl1 */
      776 
      777  /*  START OF:	oc_data.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  2     2 
  2     3 	
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(85-11-14,Farley), approve(85-11-14,MCR6979),
  2     6*     audit(85-11-14,Fawcett), install(86-03-21,MR12.0-1033):
  2     7*     Add support for MCA
  2     8*     and IMU.
  2     9*  2) change(85-12-03,Farley), approve(85-12-03,MCR7306),
  2    10*     audit(85-12-03,Fawcett), install(86-03-21,MR12.0-1033):
  2    11*     Fix bugs found while doing Dipper changes.
  2    12*  3) change(85-12-03,Farley), approve(85-12-03,MCR7312),
  2    13*     audit(85-12-03,Fawcett), install(86-03-21,MR12.0-1033):
  2    14*     Add BCE MCA lock and unlock.
  2    15*  4) change(86-08-07,Farley), approve(86-10-07,MCR7523),
  2    16*     audit(86-10-03,Fawcett), install(86-10-09,MR12.0-1181):
  2    17*     Removed timeout_factor, as it is nolonger needed.
  2    18*  5) change(89-08-28,Farley), approve(89-09-18,MCR8132),
  2    19*     audit(89-10-10,WAAnderson), install(89-10-11,MR12.3-1091):
  2    20*     Increased MAX_IO_LENGTH from 132 to 256 to be consistent with
  2    21*     oc_trans_output_.  This also affects the size of oc_data structures. Trace
  2    22*     entries have been reduced from 168 to 130.
  2    23*                                                   END HISTORY COMMENTS */
  2    24 
  2    25 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2    26 	/*										*/
  2    27 	/* Purpose:									*/
  2    28 	/*										*/
  2    29 	/* 	This include file describes the contents of the oc_data segment as well various other 	*/
  2    30 	/* 	static values utilized to interface operator's consoles. Changes to this structure that 	*/
  2    31 	/* 	would affect the size of the oc_data segment will require a change in the size of oc_data */
  2    32 	/* 	as specified in the MST header. This is true because the segment is fabricated at boot 	*/
  2    33 	/* 	time and the size must be known prior to fabrication.				*/
  2    34 	/*										*/
  2    35 	/*	This include file was recoded from its original version to add support for multiple 	*/
  2    36 	/* 	consoles.									*/
  2    37 	/*										*/
  2    38 	/* Re-written:		05/01/83							*/
  2    39 	/*										*/
  2    40 	/* Author:		E. A. Ranzenbach	(Ranzenbach.Multics@M)			*/
  2    41 	/* Location:		System-M.							*/
  2    42 	/* Release:		MR10.2							*/
  2    43 	/*										*/
  2    44 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2    45 	/*										*/
  2    46 	/* Modifications:									*/
  2    47 	/*										*/
  2    48 	/*  Date	  Author			Reason						*/
  2    49      	/*										*/
  2    50 	/*  840410  Edward A. Ranzenbach	Cut size of I/O's to 132 chars...			*/
  2    51 	/*  840427  Edward A. Ranzenbach	Added "off" console state..."				*/
  2    52 	/*  850111  Edward A. Ranzenbach	Added lost special interrupt protection.		*/
  2    53 	/*  850215  Paul K Farley               Add pcw_ignored flag in oc_entry.                           */
  2    54 	/*  850522  Paul K Farley               Add MCA lock/unlock info.                                   */
  2    55 	/*  850827  Paul K Farley               Add more info to event trace.				*/
  2    56 	/*  850913  Paul K Farley               Add timeout_factor variable to oc_entry.		*/
  2    57 	/*  851114  Paul K Farley               Remove pcw_ignored flag, imu flag will do.		*/
  2    58 	/*										*/
  2    59 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2    60 
  2    61 /* format: off */
  2    62 
  2    63 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2    64 	/*										*/
  2    65 	/* The DCW list consists of an array of sixteen single word Device Control Words that are used to	*/
  2    66 	/* drive the console devices. These DCWs are listed in their stored order followed by the effects	*/
  2    67 	/* that they produce:								*/
  2    68 	/*										*/
  2    69 	/*	1  =  reset status IDCW	->	Reset the console channel...			*/
  2    70 	/*	2  =  write alert IDCW	->	Output a bell character to the console...	*/
  2    71 	/*	3  =  write IDCW		->	Put console in output mode...			*/
  2    72 	/*	4  =  write  DCW		->	Describes intended outgoing data transfer...	*/
  2    73 	/*	5  =  write IDCW - newline	->	Put console in output mode...			*/
  2    74 	/*	6  =  write  DCW - newline	->	Describes newline transfer...			*/
  2    75 	/*	7  =  read  IDCW		->	Put the console in input mode...		*/
  2    76 	/*	8  =  read   DCW		->	Describes intended data transfer...		*/
  2    77 	/*	9  =  read_unechoed  IDCW	->	Put the console in unechoed input mode...	*/
  2    78 	/*	10 =  read_unechoed  DCW	->	Describes intended data transfer...		*/
  2    79 	/*	11 =  write IDCW - prompt							*/
  2    80 	/*	12 =  write  DCW - prompt							*/
  2    81 	/*	13 =  write IDCW - discard	->	Put console in output mode...			*/
  2    82 	/*	14 =  write  DCW - discard	->	Describes discard notice...			*/
  2    83 	/*	15 =  lock MCA IDCW		->	Disable MCA input from console...		*/
  2    84 	/*	16 =  unlock MCA IDCW	->	Enable MCA input from console...		*/
  2    85 	/*										*/
  2    86 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2    87 
  2    88      dcl	oc_data$		external;					/* so we can find it...		*/
  2    89 	
  2    90      dcl  1 oc_data			aligned	 based	 (oc_data_ptr),
  2    91 	     2 lock 		bit (36),				/* global lock for all of oc_data...	*/
  2    92 	     2 version		char	(4),			/* should equal oc_data_version...	*/
  2    93 	     2 console_cnt		fixed bin	(17)	unaligned,	/* number of configured consoles...	*/
  2    94 	     2 bootload_console_idx	fixed bin	(17)	unaligned,	/* index into opc of bootload console...*/
  2    95 	     2 flags,
  2    96 		3 in_service	bit	(1)	unaligned,	/* ON => at least one usable console... */
  2    97 		3 crash_on_crf	bit	(1)	unaligned,	/* ON => crash on recovery failure...	*/
  2    98 		3 mc_io_enabled	bit	(1)	unaligned,	/* ON => MC is handling I/O...	*/
  2    99 		3 list_consoles	bit	(1)	unaligned,	/* ON => list the console assignments...*/
  2   100 		3 printer_on	bit	(1)	unaligned,	/* ON => echo read characters...	*/
  2   101 		3 write_q_full	bit	(1)	unaligned,	/* ON => the write queue is full...	*/
  2   102 		3 must_have_console	bit	(1)	unaligned,	/* ON => we must have a real console... */
  2   103 		3 pad_oc_data_flags	bit	(29)	unaligned,	/* pad to word boundry...		*/
  2   104 	     2 no_lock_flags,					/* these flags can be modified without	*/
  2   105 								/* lock protection...		*/
  2   106 		3 got_special_int	bit	(1)	unaligned,	/* we could not process this special... */
  2   107 		3 pad_no_lock_flags	bit	(35)	unaligned,
  2   108 	     2 pad_misc		fixed bin	(35),			/* to preserve even word alignment...	*/
  2   109 	     2 prompt		char	(8),			/* string used to prompt for input...	*/
  2   110 	     2 discard_notice	char	(24),			/* displayed at BREAK condition...	*/
  2   111 	     2 write_return		bit	(36),			/* newline string = PAD PAD CR NL...	*/
  2   112 	     2 abs_addr		fixed bin (26),			/* absolute address of oc_data$...	*/
  2   113 	     2 status_ptr		ptr,				/* points to IOM status word...	*/
  2   114 	     2 io_ptr		ptr,				/* -> I/O being processed...		*/
  2   115 	     2 last_read_queued	fixed bin	(71),			/* last time a READ was queued...	*/
  2   116 	     2 last_write_queued	fixed bin (71),			/* last time a WRITE was queued...	*/
  2   117 	     2 last_poll_time	fixed bin	(71),			/* last time of timeout poll by pxss...	*/
  2   118 	     2 max_computed_io_time	fixed bin	(71),			/* maximum time an I/O could take...	*/
  2   119 	     2 err_event_cid	fixed bin (71),			/* channel used to signal inop state... */
  2   120 	     2 err_event_pid	bit	(36),			/* ID of process handling inop states...*/
  2   121 	     2 reader_process_id	bit	(36),			/* only process allowed to read...	*/
  2   122 	     2 next_free_write	fixed bin	(17)	unaligned,	/* index of the next free WRITE slot... */
  2   123 	     2 next_event		fixed bin	(17)	unaligned,	/* next event index...		*/
  2   124 	     2 stacked_read_cnt	fixed bin	(17)	unaligned,	/* READ stack...			*/
  2   125 	     2 pad_oc_data		bit	(18)	unaligned,
  2   126 	     2 priority_io	like	console_io,			/* oc_data|42(8)...			*/
  2   127 	     2 read_io	like	console_io,			/* oc_data|154(8)...		*/
  2   128 	     2 write_queue		(WRITE_QUEUE_SIZE)			/* oc_data|266(8)...		*/
  2   129 			like	console_io,
  2   130 	     2 meters,						/* metering cell at oc_data|1406...	*/
  2   131 		3 pushed_read_cnt	fixed bin	(35),			/* count of times read stack was used...*/
  2   132 		3 write_q_full_cnt	fixed bin	(35),			/* count of WRITE fails for no room...	*/
  2   133 		3 queued_special_int_count
  2   134 				fixed bin	(35),
  2   135 		3 pad_meters(7)	fixed bin	(35),			/* for future use...		*/
  2   136 	     2 opc	(MAX_OPC_CNT)				/* oc_data|1420, 1454, 1510, 1544, 1600...*/
  2   137 			like	oc_entry,				/* 1634, 1670, 1724...		*/
  2   138 	     2 event	(EVENT_QUEUE_SIZE)				/* oc_data|1760 thru oc_data|3777...	*/
  2   139 			like 	oc_event;
  2   140 
  2   141 
  2   142 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2   143 	/*										*/
  2   144 	/* The following structure describes a configured console.					*/
  2   145 	/*										*/
  2   146 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2   147 
  2   148 	
  2   149      dcl	1 oc_entry	aligned	based	(oc_entry_ptr),		/* one for each console 34(8) words... */
  2   150 	     2 name		char	(4),			/* name of this console, i.e. "opca"... */
  2   151 	     2 opc_idx		fixed bin	(17)	unaligned,	/* index of this entry in opc array...	*/
  2   152 	     2 model		fixed bin	(17)	unaligned,	/* model of the console...		*/
  2   153 	     2 flags,
  2   154 		3 active		bit	(1)	unaligned,	/* ON => this entry is in use...	*/
  2   155 		3 assigned	bit	(1)	unaligned,	/* ON => io_manager knows device...	*/
  2   156 		3 bootload_console	bit	(1)	unaligned,	/* ON => this is the bootload console...*/
  2   157 		3 alternate	bit	(1)	unaligned,	/* ON => console used if active fails...*/
  2   158 		3 inop_device	bit	(1)	unaligned,	/* ON => console is inoperative...	*/
  2   159 		3 io_device	bit	(1)	unaligned,	/* ON => console is not available to us.*/
  2   160 		3 no_device	bit	(1)	unaligned,	/* ON => console has been deleted...	*/
  2   161 		3 config_change	bit	(1)	unaligned,	/* ON => config change has occurred...	*/
  2   162 		3 prompt		bit	(1)	unaligned,	/* ON => prompt for input...		*/
  2   163 		3 pcw_io		bit	(1)	unaligned,	/* ON => use PCW's instead of IDCW's... */
  2   164 		3 io_in_progress	bit	(1)	unaligned,	/* ON => I/O op is in progress...	*/
  2   165 		3 got_special_int	bit	(1)	unaligned,	/* ON => RE(TURN QUEST) key was hit...	*/
  2   166 		3 oper_request	bit	(1)	unaligned,	/* ON => operator has hit request key...*/
  2   167 		3 discard		bit	(1)	unaligned,	/* ON => discard output...		*/
  2   168 		3 discarded	bit	(1)	unaligned,	/* ON => (output discarded) printed...	*/
  2   169 		3 read_unechoed_option				/* ON => read_unechoed option installed.*/
  2   170 				bit	(1)	unaligned,	/* option must not be installed...	*/
  2   171 		3 imu		bit	(1)	unaligned,	/* ON => console located in an IMU...	*/
  2   172 		3 pad_flag	bit	(19)	unaligned,	/* pad to word boundry...		*/
  2   173 	     2 channel		char	(8),			/* name of this console's channel...	*/
  2   174 	     2 device_idx		fixed bin (35),			/* operator's console device id...	*/
  2   175 	     2 line_leng		fixed bin	(17)	unaligned,	/* line length of the console...	*/
  2   176 	     2 dcw_list_idx		fixed bin	(17)	unaligned,	/* DCW list in progess...		*/
  2   177 	     2 retry_cnt		fixed bin	(17)	unaligned,	/* times I/O op has been retried...	*/
  2   178 	     2 RESERVED_PAD		fixed bin	(17)	unaligned,	/* pad to oc_entry + 10(8)...		*/
  2   179 	     2 io_time		fixed bin (71),			/* time last I/O began...		*/
  2   180 	     2 status_word		bit	(36),			/* last valid status word received...	*/
  2   181 	     2 dcw_list	(16)	bit	(36),			/* DCWs used to drive the console...	*/
  2   182 	     2 pad_oc_entry_end	bit	(36);			/* pad to 34(8) words...		*/
  2   183 
  2   184 
  2   185 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2   186 	/*										*/
  2   187 	/* This is the format of a console I/O. A pointer to this structure is passed to us by the process	*/
  2   188 	/* wishing to perform a console I/O. The caller will fill in the following things for a read I/O:	*/
  2   189 	/*										*/
  2   190 	/* 	console_io.event_chan	- Will be an event channel to wake the user on when the	*/
  2   191 	/* 				  I/O completes.					*/
  2   192 	/*										*/
  2   193 	/* 	console_io.read		- Set to "1"b indicating a read.			*/
  2   194 	/*										*/
  2   195 	/*  For a write the following information is supplied:					*/
  2   196 	/*										*/
  2   197 	/* 	console_io.alert		- Set to "1"b if the console alarm is to be on for the	*/
  2   198 	/* 				  write.						*/
  2   199 	/*										*/
  2   200 	/* 	console_io.read		- Set to "0"b.					*/
  2   201 	/*										*/
  2   202 	/* 	console_io.sequence_no	- Set to the syserr sequence number for syserr calls. 	*/
  2   203 	/*										*/
  2   204 	/* 	console_io.leng		- Set to the word length of the message to be written.	*/
  2   205 	/*										*/
  2   206 	/* 	console_io.text		- Set to the text of the message.			*/
  2   207 	/*										*/
  2   208 	/* In all cases ocdcm_ will properly reset those items not necessary to the type of I/O being 	*/
  2   209 	/* performed.									*/
  2   210 	/*										*/
  2   211 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2   212 
  2   213      dcl	1 console_io		aligned 	based 	(console_io_ptr),	/* format of a I/O, 112(8) words...	*/
  2   214 	     2 time_queued		fixed bin	(71),			/* 0 indicates a free entry...	*/
  2   215 	     2 event_chan		fixed bin (71),			/* to send wakeup to when I/O completes.*/
  2   216 	     2 process_id		bit	(36),			/* of the caller...			*/
  2   217 	     2 console		char	(4),			/* name of the console the I/O went to..*/
  2   218 	     2 flags,						/* start at console_io + 6(8)...	*/
  2   219 		3 alert		bit	(1)	unaligned,	/* ON => ring bell first...		*/
  2   220 		3 read		bit	(1)	unaligned,	/* ON => this is a read request...	*/
  2   221 		3 alerted		bit	(1)	unaligned,	/* ON => we have successfully alerted...*/
  2   222 		3 prompted	bit	(1)	unaligned,	/* ON => we have successfully prompted..*/
  2   223 		3 in_progress	bit	(1)	unaligned,	/* ON => I/O has been started...	*/
  2   224 		3 completed	bit	(1)	unaligned,	/* ON => the I/O has completed...	*/
  2   225 		3 retry_reset	bit	(1)	unaligned,	/* ON => I/O was reset by retry_io...	*/
  2   226 		3 pad_flag	bit	(29)	unaligned,	/* pad to word boundry...		*/
  2   227 	     2 sequence_no		fixed bin	(35),			/* syserr sequence number...		*/
  2   228 	     2 leng		fixed bin	(17)	unaligned,	/* in words of the I/O...		*/
  2   229 	     2 MBZ		fixed bin	(17)	unaligned,	/* reserved for future use...		*/
  2   230 	     2 pad_text		fixed bin	(35),			/* I/O must start on even word boundry..*/
  2   231 	     2 text		char	(MAX_IO_LENGTH);		/* the actual I/O...		*/
  2   232 
  2   233 
  2   234 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2   235 	/*										*/
  2   236 	/* The following structure is used to log an event occurring in in the console software.		*/
  2   237 	/*										*/
  2   238 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2   239 
  2   240 	
  2   241      dcl	1 oc_event		aligned	based	(oc_event_ptr),	/* each event is 10(8) words long...	*/
  2   242 	     2 time		fixed bin	(71),			/* time event took place...		*/
  2   243 	     2 opc_name		char (4),				/* bootload console at time of event... */
  2   244 	     2 opc_flags		like oc_entry.flags,		/* bootload console flags...		*/
  2   245 	     2 process_id		bit	(36),			/* process logging the event...	*/
  2   246 	     2 event_number		fixed bin	(35),			/* number of the event being logged...	*/
  2   247 	     2 event_io_ptr		ptr;				/* ptr to I/O in progress during event..*/
  2   248 
  2   249      dcl	(							/* indices for ease of use...		*/
  2   250 	RESET_DCW			init	(1),
  2   251 	ALERT_DCW			init	(2),
  2   252 	WRITE_DCW			init	(3),
  2   253 	NEWLINE_DCW		init	(5),
  2   254 	READ_DCW			init	(7),
  2   255 	READ_UNECHOED_DCW		init	(9),
  2   256 	PROMPT_DCW		init	(11),
  2   257 	DISCARD_DCW		init	(13),
  2   258 	LOCK_MCA_DCW		init	(15),
  2   259 	UNLOCK_MCA_DCW		init	(16)
  2   260 	)			fixed bin	(17)
  2   261 				internal static	options (constant);
  2   262      dcl	(							/* list of event numbers...		*/
  2   263 	INIT_OC_DATA		init	(1),
  2   264 	GOT_SPECIAL_INT		init	(2),
  2   265 	PRIORITY_OUTPUT		init	(3),
  2   266 	QUEUED_READ		init	(4),
  2   267 	QUEUED_WRITE		init	(5),
  2   268 	STARTED_READ		init	(6),
  2   269 	STARTED_UNECHOED_READ	init	(7),
  2   270 	STARTED_WRITE		init	(8),
  2   271 	RESET_CHANNEL		init	(9),
  2   272 	SENT_ALERT		init	(10),
  2   273 	SENT_NEWLINE		init	(11),
  2   274 	SENT_PROMPT		init	(12),
  2   275 	TERMINATED_RESET		init	(13),
  2   276 	TERMINATED_ALERT		init	(14),
  2   277 	TERMINATED_NEWLINE		init	(15),
  2   278 	TERMINATED_PROMPT		init	(16),
  2   279 	TERMINATED_READ		init	(17),
  2   280 	TERMINATED_WRITE		init	(18),
  2   281 	SENT_WAKEUP		init	(19),
  2   282 	READ_PICKUP		init	(20),
  2   283 	PUSHED_READ		init	(21),
  2   284 	POPPED_READ		init	(22),
  2   285 	READ_NOT_IN_PROGRESS	init	(23),
  2   286 	LOGGED_ERROR		init	(24),
  2   287 	IO_TIMEOUT		init	(25),
  2   288 	RETRY_IO			init	(26),
  2   289 	GOT_LOCK			init	(27),
  2   290 	FREED_LOCK		init	(28),
  2   291 	DISCARDED_OUTPUT		init	(29),
  2   292 	SENT_MC_IO		init	(30),
  2   293 	SENT_MC_PRIORITY_IO		init	(31),
  2   294 	MC_IO_PICKUP		init	(32),
  2   295 	MC_IO_FAILURE		init	(33),
  2   296 	LOCK_MCA_IO		init	(34),
  2   297 	UNLOCK_MCA_IO		init	(35),
  2   298 	TERMINATED_MCA_LOCK		init	(36),
  2   299 	TERMINATED_MCA_UNLOCK	init	(37)
  2   300 	)			fixed bin	(35)
  2   301 				internal static	options (constant);
  2   302 
  2   303      dcl	oc_data_version		char	(4)	init	("1.3")	/* for general information...		*/
  2   304 				static internal	options (constant);
  2   305 
  2   306      dcl	(
  2   307 	oc_data_ptr,
  2   308 	oc_entry_ptr,
  2   309 	oc_event_ptr,
  2   310 	console_io_ptr
  2   311 	)			ptr;
  2   312 
  2   313      dcl	(
  2   314 	MAX_OPC_CNT		init	(8),			/* maximum number of consoles...	*/
  2   315 	MAX_RETRIES		init	(2),			/* we retry I/O ops this many times...	*/
  2   316 	EVENT_QUEUE_SIZE		init	(130),			/* use up the rest of the 2 pages...	*/
  2   317 	WRITE_QUEUE_SIZE		init	(8)			/* number of queued writes allowed...	*/
  2   318 	)
  2   319 				fixed bin	(17)
  2   320 				internal static	options (constant);
  2   321 
  2   322      dcl	MAX_IMU_IO_TIME		fixed bin	(17)			/* longest possible IMU I/O time...	*/
  2   323 				internal static	options (constant)
  2   324 				init	(150);			/* 2 minutes 30 seconds...		*/
  2   325 
  2   326      dcl	MAX_IO_TIME	(16)	fixed bin	(17)			/* maximum time the associated I/O 	*/
  2   327 				internal static	options (constant)	/* operation is allowed to take in 	*/
  2   328 				init				/* seconds...			*/
  2   329 			         (
  2   330 				1,				/* RESET_STATUS...			*/
  2   331 				1,				/* WRITE ALERT...			*/
  2   332 				10,				/* WRITE DATA...			*/
  2   333 				0,				/* DUMMY for WRITE DATA DCW...	*/
  2   334 				2,				/* WRITE CR, NL...			*/
  2   335 				0,				/* DUMMY for WRITE CR, NL DCW...	*/
  2   336 				90,				/* READ DATA...			*/
  2   337 				0,				/* DUMMY for READ DATA DCW...		*/
  2   338 				90,				/* READ_UNECHOED DATA...		*/
  2   339 				0,				/* DUMMY for READ_UNECHOED DATA DCW...	*/
  2   340 				1,				/* WRITE PROMPT...			*/
  2   341 				0,				/* DUMMY for WRITE PROMPT DCW...	*/
  2   342 				10,				/* DISCARD DCW...			*/
  2   343 				0,				/* DUMMY for DISCARD DCW...		*/
  2   344 				30,				/* LOCK MCA IO...			*/
  2   345 				30				/* UNLOCK MCA IO...			*/
  2   346 				);
  2   347 
  2   348      dcl	MAX_IO_LENGTH		fixed bin	(17)
  2   349 				internal static	options (constant)
  2   350 				init	(256);			/* in characters...			*/
  2   351      dcl	MAX_MAX_IO_TIME		fixed bin	(17)			/* longest possible I/O time...	*/
  2   352 				internal static	options (constant)
  2   353 				init	(150);			/* should be the same as the longest...	*/
  2   354 
  2   355 
  2   356 /*  END OF:	oc_data.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      777 
      778  /* Begin include file ..... syserr_actions.incl.pl1 */
  3     2 
  3     3 /* Created November 1975 by Larry Johnson */
  3     4 /* These arrays map the action codes into actions syserr must provide. */
  3     5 
  3     6 /* write: Codes for message should be written on operator console */
  3     7 /* alarm: Codes which should sound alram when written */
  3     8 /* crash: Codes which should cause system to crash */
  3     9 /* termp: Codes for which the callers process should be terminated */
  3    10 /* wifnl: Codes for messages which should be written if they can't be logged */
  3    11 
  3    12 dcl  write_flags (0:9) bit (1) unal int static init ("1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b);
  3    13 dcl  alarm_flags (0:9) bit (1) unal int static init ("0"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b);
  3    14 dcl  crash_flags (0:9) bit (1) unal int static init ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b);
  3    15 dcl  termp_flags (0:9) bit (1) unal int static init ("0"b, "0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b);
  3    16 dcl  wifnl_flags (0:9) bit (1) unal int static init ("0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b);
  3    17 
  3    18 /* End include file ..... syserr_actions.incl.pl1 */
      778 
      779  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  4     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  4     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  4     4 
  4     5 /* This include file has an ALM version.  Keep 'em in sync! */
  4     6 
  4     7 dcl (
  4     8 
  4     9 /* The following constants define the message action codes.  This indicates
  4    10*how a message is to be handled.  */
  4    11 
  4    12      SYSERR_CRASH_SYSTEM	init (1),			
  4    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  4    14 
  4    15      SYSERR_TERMINATE_PROCESS	init (2),
  4    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  4    17 
  4    18      SYSERR_PRINT_WITH_ALARM	init (3),
  4    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  4    20 
  4    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  4    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  4    23 
  4    24      SYSERR_LOG_OR_PRINT	init (4),
  4    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  4    26 
  4    27      SYSERR_LOG_OR_DISCARD	init (5),
  4    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  4    29 
  4    30 
  4    31 /* The following constants are added to the normal severities to indicate
  4    32*different sorting classes of messages.  */
  4    33 
  4    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  4    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  4    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  4    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  4    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  4    39 	) fixed bin internal static options (constant);
  4    40 
  4    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      779 
      780  /* BEGIN INCLUDE FILE  syserr_data.incl.pl1 */
  5     2 
  5     3 /* Created by  Bill Silver  on 01/03/73. */
  5     4 /* Modified September 1975 by Larry Johnson to add binary data */
  5     5 /* Modified March 1976 by Steve Webber for use with cds */
  5     6 /* Modified 1985-01-21 by EJ Sharpe: added wmess.process_id */
  5     7 /* Modified 1985-02-18 by Keith Loepere to break out headers. */
  5     8 
  5     9 /* This include file defines the syserr and log areas found in  syserr_data.cds
  5    10*   There is one lock that coordinates the use of all the data found in
  5    11*   syserr_data.cds.  NOTE, if this include file changes, syserr_data.cds
  5    12*   may also have to be changed. */
  5    13 
  5    14 dcl  syserr_data$syserr_area char (1) aligned external,
  5    15      syserr_data$wired_log_area char (1) aligned external;
  5    16 
  5    17 dcl  sd_ptr ptr,					/* Pointer to beginning of syserr_area. */
  5    18      wlog_ptr ptr,					/* Pointer to beginning of wired_log_area. */
  5    19      wmess_ptr ptr;					/* Pointer to a message entry in the wired log. */
  5    20 
  5    21 dcl 1 sd based (sd_ptr) aligned,			/* Overlay of syserr_data$syserr_area. */
  5    22     2 lock bit (36),				/* Locks all the data in syserr_data. */
  5    23     2 log_flag bit (1) unal,				/* ON => logging mechanism enabled. */
  5    24     2 char_type_flag bit (1) unal,			/* ON => ASCII,  OFF => BCD. */
  5    25     2 ocdcm_init_flag bit (1) unal,			/* ON => ocdcm_ has been initialized. */
  5    26     2 pad bit (33) unal,
  5    27     2 prev_text_written char (80);			/* Text of last message written */
  5    28 
  5    29 dcl 1 wlog based (wlog_ptr) aligned,			/* Overlay of syserr_data$wired_log_area. */
  5    30     2 head like wlog_header,				/* Wired log header. */
  5    31     2 buffer (wlog.head.bsize) bit (36);		/* Wired log buffer. */
  5    32 
  5    33 dcl 1 wlog_header based aligned,			/* WIRED LOG HEADER */
  5    34     2 bsize fixed bin,				/* Size of the wired log buffer in words.
  5    35*						   Defined in syserr_data.cds. */
  5    36     2 count fixed bin,				/* Num of message entries in wired log. */
  5    37     2 slog_ptr ptr,					/* Pointer to the paged log segment: syserr_log. */
  5    38     2 seq_num fixed bin (35),				/* Sequence number of last message logged. */
  5    39     2 next bit (18) unal,				/* Offset relative to base syserr_data */
  5    40 						/* Where next entry will go in wired log. */
  5    41     2 pad bit (18) unal;
  5    42 
  5    43 
  5    44 /* This is an overlay of a message entry that goes into the wired log.  Each message
  5    45*   entry corresponds to one syserr message. */
  5    46 
  5    47 dcl 1 wmess based (wmess_ptr) aligned,
  5    48     2 header aligned like wmess_header,
  5    49     2 text char (0 refer (wmess.text_len)),		/* Text of expanded message - kept in ASCII. */
  5    50     2 data (0 refer (wmess.data_size)) bit (36);		/* Binary data area */
  5    51 
  5    52 dcl 1 wmess_header based aligned,
  5    53     2 seq_num fixed bin (35),				/* Sequence number of this message. */
  5    54     2 time fixed bin (71) unal,			/* Time message logged at */
  5    55     2 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  5    56     2 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  5    57     2 data_size fixed bin (11) unal,			/* Size of binary data */
  5    58     2 data_code fixed bin (11) unal,			/* Data code */
  5    59     2 pad bit (24) unal,
  5    60     2 process_id bit (36);				/* ID of process which wrote message */
  5    61 
  5    62 /* END INCLUDE FILE syserr_data.incl.pl1 */
      780 
      781  /* BEGIN INCLUDE FILE ... syserr_log_dcls.incl.pl1 ... 84-08-17 ... W. Olin Sibert */
  6     2 /* Modified 1984-12-10, BIM: changed to a fast lock, added error count. */
  6     3 
  6     4 /* The syserr_log_data segment, made reverse-deciduous in >sl1, overlays the
  6     5*   first page of the LOG partition, and contains control information about
  6     6*   the other syserr_log segments. */
  6     7 
  6     8 declare   syserr_log_data$    fixed bin external static;
  6     9 declare   syserr_log_data_ptr pointer;
  6    10 
  6    11 declare 1 syserr_log_data     aligned based (syserr_log_data_ptr),
  6    12           2 version           char (8) unaligned,           /* SYSERR_LOG_DATA_V1 */
  6    13           2 old_init_word     char (4) unaligned,           /* Overlays slog.head.init_word ("INIT") */
  6    14 	2 pad003    	bit (1) aligned,
  6    15 
  6    16           2 live_log          fixed bin,                    /* Identifier of live log (#1 or #2) */
  6    17 	2 pad001		bit (1) aligned,
  6    18           2 error_count       fixed bin (35),               /* errors copying the log */
  6    19           2 swap_time         fixed bin (71),               /* Time of last log swap; zero if other_log_empty */
  6    20 
  6    21           2 messages_copied   fixed bin (35),               /* A meter */
  6    22           2 messages_lost     fixed bin (35),               /* Messages not copied because logs full */
  6    23 
  6    24           2 log_start (2)     fixed bin,                    /* Offset of each log segment in the partition */
  6    25           2 log_size (2)      fixed bin,                    /* Number of pages in each log segment */
  6    26 
  6    27           2 per_bootload,                                   /* Ramaining structure is reinitialized at each boot */
  6    28             3 log_ptr (2) pointer,                          /* Pointer to the three segments in the partition */
  6    29 
  6    30             3 log_name (2) char (32) unaligned,             /* Current names of log segments (by syserr_seg_manager) */
  6    31             3 log_dir char (168) unaligned,                 /* Parent directory */
  6    32 
  6    33             3 lock		aligned,
  6    34 	    4 pid		bit (36) aligned,             /* Standard format wait lock, used when updating log */
  6    35               4 event_id      fixed bin (35),
  6    36               4 notify_requested 
  6    37 	                    bit (1) unaligned,
  6    38 	    4 pad           bit (35) unaligned,
  6    39             3 take_a_fault    bit (1) aligned,              /* Forces a fault if on, for testing fault recovery */
  6    40             3 test_mode       bit (1) aligned,              /* Running in outer-ring test mode */
  6    41 
  6    42             3 copy_disabled   bit (1) aligned,              /* No more messages being copied into live log */
  6    43             3 drop_severity_5 bit (1) aligned,              /* No more severity 5 messages (log is 3/4 full) */
  6    44 	  3 wakeup_on_printable bit (1) aligned,	/* Console recovery: send wakeup for printable message */
  6    45 
  6    46             3 copy_threshold  fixed bin (18),               /* How often to copy to outer ring log segments */
  6    47             3 copy_channel    fixed bin (71),
  6    48             3 copy_process_id bit (36) aligned,
  6    49 
  6    50           2 pad fixed bin (71);                             /* Anything goes, as long as it's under a page */
  6    51 
  6    52 declare   SYSERR_LOG_DATA_V1 char (8) internal static options (constant) init ("syserr01");
  6    53 
  6    54 /* END INCLUDE FILE ... syserr_log_dcls.incl.p1l */
      781 
      782 
      783 /*	BEGIN MESSAGE DOCUMENTATION
      784*
      785*   Message:
      786*   syserr: Mylock error.
      787*
      788*   S:	$crash
      789*
      790*   T:	$run
      791*
      792*   M:	$err
      793*
      794*   A:	$recover
      795*
      796*
      797*   Message:
      798*   Now terminating user process: PERSON.PROJ.
      799*
      800*   S:	$info
      801*
      802*   T:	$run
      803*
      804*   M:	This line is always preceded by an explanation
      805*   of the error which required the terminaation of the user process
      806*   PERSON.PROJ.
      807*
      808*   A:	$ignore
      809*
      810*
      811*   Message:
      812*   Multics not in operation; control process: PERSON.PROJ.
      813*
      814*   S:	$crash
      815*
      816*   T:	$run
      817*
      818*   M:	This message is always preceded
      819*   by an explanation of the error which crashed the system.
      820*
      821*   A:	$recover
      822*
      823*
      824*   Message:
      825*   syserr: Bad ring 1 call.
      826*
      827*   S:	$log
      828*
      829*   T:	$run
      830*
      831*   M:	A bad call to syserr was made from ring 1.
      832*   The system keeps running.
      833*
      834*   A:	$ignore
      835*
      836*
      837*   END MESSAGE DOCUMENTATION */
      838 
      839      end syserr_real;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0804.9  syserr_real.pl1                   >spec>install>1111>syserr_real.pl1
776          1    04/30/87  1513.7  flagbox.incl.pl1                  >ldd>include>flagbox.incl.pl1
777          2    10/12/89  2017.7  oc_data.incl.pl1                  >ldd>include>oc_data.incl.pl1
778          3    02/12/76  1502.4  syserr_actions.incl.pl1           >ldd>include>syserr_actions.incl.pl1
779          4    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
780          5    03/08/85  0852.7  syserr_data.incl.pl1              >ldd>include>syserr_data.incl.pl1
781          6    01/06/85  1422.2  syserr_log_dcls.incl.pl1          >ldd>include>syserr_log_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000063 constant        fixed bin(17,0)          initial dcl 4-7 set ref 605*
CR_NL                                  based           char(5)                  packed unaligned dcl 139 ref 573
CR_NL_bits                      000046 constant        bit(45)                  initial packed unaligned dcl 239 set ref 573
LOG                             000067 constant        fixed bin(17,0)          initial dcl 4-7 set ref 593*
MAX_IO_LENGTH                          constant        fixed bin(17,0)          initial dcl 2-348 ref 112 584
add                                                    builtin function         dcl 234 ref 503
addcharno                                              builtin function         dcl 234 ref 579
addr                                                   builtin function         dcl 234 ref 376 379 379 401 424 442 486 529 549 573
                                                                                  586 586 633 645 705 731 741 741 753 772
addrel                                                 builtin function         dcl 234 ref 308 529 737 738 739 773
alarm_flag                      000100 automatic       bit(1)                   dcl 87 set ref 391* 525 567 581*
alarm_flags                     000003 constant        bit(1)                   initial array packed unaligned dcl 3-13 ref 391
alert                    43(04)        based           bit(1)                   level 3 in structure "fgbx" packed packed unaligned
                                                                                  dcl 1-24 in procedure "syserr_real" set ref 647*
alert                     6     000160 automatic       bit(1)                   level 3 in structure "oc_io" packed packed unaligned
                                                                                  dcl 112 in procedure "syserr_real" set ref 567*
arg_code                               parameter       fixed bin(17,0)          dcl 75 ref 25 262 284 316 334 343 352 361 667 686
arg_count_                      000010 constant        entry                    external dcl 193 ref 338 347 356 364
arg_data_code                          parameter       fixed bin(17,0)          dcl 76 ref 262 275 284 303 352 361
arg_data_len                           parameter       fixed bin(17,0)          dcl 77 ref 262 268 352
arg_data_pieces_array_ptr              parameter       pointer                  dcl 78 ref 284 290 361
arg_data_ptr                           parameter       pointer                  dcl 79 ref 262 276 352
arg_error_code                         parameter       pointer                  packed unaligned dcl 80 ref 316 343 751 752
arg_list_ptr                    000102 automatic       pointer                  dcl 88 set ref 255* 271* 298* 326* 741*
arg_list_ptr_                   000012 constant        entry                    external dcl 194 ref 255 271 298 326
arg_n_data_pieces                      parameter       fixed bin(17,0)          dcl 81 ref 284 292 361
arg_panic_mess                         parameter       char                     packed unaligned dcl 82 ref 642 646
auto_mbuf                       000104 automatic       structure                level 1 dcl 89 set ref 529
auto_wlog_header                000114 automatic       structure                level 1 dcl 92 ref 620
auto_wmess_header               000122 automatic       structure                level 1 dcl 93 set ref 506 622 731 772
bad_ring1_msg                   000040 constant        char(24)                 initial packed unaligned dcl 241 set ref 664*
baseno                                                 builtin function         dcl 234 ref 753
bin                                                    builtin function         dcl 234 ref 463 503
binary_call                     000130 automatic       bit(1)                   packed unaligned dcl 94 set ref 274* 302* 474 475*
                                                                                  659* 682*
binary_data                            based           bit(36)                  array dcl 152 set ref 276* 276
bit                                                    builtin function         dcl 234 ref 503
bsize                                  based           fixed bin(17,0)          level 3 dcl 5-29 ref 463
buffer                    6            based           bit(36)                  array level 2 dcl 5-29 set ref 442
byte                                                   builtin function         dcl 234 ref 572
cleanup                         000322 stack reference condition                dcl 232 ref 370
clock                                                  builtin function         dcl 234 ref 393
code                            000131 automatic       fixed bin(17,0)          dcl 95 in procedure "syserr_real" set ref 395 667*
                                                                                  668 669* 669 670 670 670* 671* 671 686* 687
code                      3     000122 automatic       fixed bin(11,0)          level 2 in structure "auto_wmess_header" packed
                                                                                  packed unaligned dcl 93 in procedure "syserr_real"
                                                                                  set ref 395*
comma                     2(18) 000104 automatic       char(2)                  level 4 packed packed unaligned dcl 89 set ref 489*
console_io                             based           structure                level 1 dcl 2-213
cont_flag                       000132 automatic       bit(1)                   dcl 96 set ref 550* 563*
copying_permitted               000133 automatic       bit(1)                   dcl 97 set ref 374* 379* 403 436 618
count                     1            based           fixed bin(17,0)          level 3 dcl 5-29 set ref 440 443* 445* 504* 504 619
                                                                                  621*
crash_flags                     000002 constant        bit(1)                   initial array packed unaligned dcl 3-14 ref 379 599
crash_msg                       000024 constant        char(46)                 initial packed unaligned dcl 242 set ref 605*
cs_pos                          000134 automatic       fixed bin(17,0)          dcl 98 set ref 249* 265* 287* 319* 337* 346* 355*
                                                                                  363* 663 741* 741
currentsize                                            builtin function         dcl 234 ref 731 772
data_code                       000135 automatic       fixed bin(17,0)          dcl 99 in procedure "syserr_real" set ref 275* 303*
                                                                                  399 660* 683*
data_code                 4     000122 automatic       fixed bin(11,0)          level 2 in structure "auto_wmess_header" packed
                                                                                  packed unaligned dcl 93 in procedure "syserr_real"
                                                                                  set ref 399*
data_len                        000136 automatic       fixed bin(17,0)          dcl 100 set ref 252* 268* 273 276 293* 295* 295 301
                                                                                  324* 729 773
data_piece                             based           bit(36)                  array dcl 153 set ref 307* 307
data_piece_len                  000137 automatic       fixed bin(17,0)          dcl 101 set ref 306* 307 308
data_piece_ptr                  000140 automatic       pointer                  dcl 102 set ref 304* 307 308* 308
data_pieces_array                      based           structure                array level 1 dcl 155
data_pieces_array_ptr           000142 automatic       pointer                  dcl 103 set ref 290* 295 306 307
data_ptr                        000144 automatic       pointer                  dcl 104 set ref 276 304 773*
data_size                 3(24) 000122 automatic       fixed bin(11,0)          level 2 in structure "auto_wmess_header" packed
                                                                                  packed unaligned dcl 93 in procedure "syserr_real"
                                                                                  set ref 476 477* 729*
data_size                 3(24)        based           fixed bin(11,0)          level 3 in structure "wmess" packed packed unaligned
                                                                                  dcl 5-47 in procedure "syserr_real" set ref 731
                                                                                  772
divide                                                 builtin function         dcl 234 ref 427 429 430 574 669
equal                     6     000104 automatic       char(4)                  level 2 packed packed unaligned dcl 89 set ref 530*
                                                                                  531*
error_table_$                   000060 external static fixed bin(17,0)          dcl 217 set ref 753
error_table_call                000146 automatic       bit(1)                   packed unaligned dcl 105 set ref 322* 661* 684* 750
error_table_code                000147 automatic       fixed bin(35,0)          dcl 106 set ref 595* 749* 752* 756*
et                                     based           structure                level 1 dcl 160
etmsgp                          000150 automatic       pointer                  dcl 107 set ref 751* 753 753* 753 756 760 763 763
event_chan                2     000160 automatic       fixed bin(71,0)          level 2 dcl 112 set ref 569*
fgbx                                   based           structure                level 1 dcl 1-24
fgbxp                           000330 automatic       pointer                  dcl 1-22 set ref 645* 646 647 647
flagbox$                        000106 external static fixed bin(17,0)          dcl 1-21 set ref 645
flags                     2            based           structure                level 2 in structure "oc_entry" dcl 2-149
                                                                                  in procedure "syserr_real"
flags                                  based           structure                array level 3 in structure "oc_data" dcl 2-90
                                                                                  in procedure "syserr_real"
flags                     6     000160 automatic       structure                level 2 in structure "oc_io" dcl 112 in procedure
                                                                                  "syserr_real"
formline_                       000014 constant        entry                    external dcl 195 ref 741
head                                   based           structure                level 2 dcl 5-29
header                                 based           structure                level 2 in structure "wmess" dcl 5-47 in procedure
                                                                                  "syserr_real" set ref 506*
header                          000104 automatic       structure                level 2 in structure "auto_mbuf" dcl 89 in procedure
                                                                                  "syserr_real" set ref 540
header                                 based           structure                level 2 in structure "mbuf" dcl 167 in procedure
                                                                                  "syserr_real"
hh                        4     000104 automatic       picture(2)               level 4 packed packed unaligned dcl 89 set ref 429*
len                                    based           fixed bin(8,0)           level 2 in structure "et" packed packed unaligned
                                                                                  dcl 160 in procedure "syserr_real" ref 760 763
len                       2            based           fixed bin(17,0)          array level 2 in structure "data_pieces_array"
                                                                                  dcl 155 in procedure "syserr_real" ref 295 306
len_for_et                      000412 automatic       fixed bin(17,0)          dcl 723 set ref 758* 760* 760 761 763 765
leng                     10     000160 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 112 set ref 583*
length                                                 builtin function         dcl 234 ref 425 487 535 572
lock                    116            based           structure                level 3 in structure "syserr_log_data" dcl 6-11
                                                                                  in procedure "syserr_real"
lock                                   based           bit(36)                  level 2 in structure "sd" dcl 5-21 in procedure
                                                                                  "syserr_real" set ref 633* 697 697 704 705
lock_msg                        000016 constant        char(21)                 initial packed unaligned dcl 243 set ref 704*
log_flag                  1            based           bit(1)                   level 2 packed packed unaligned dcl 5-21 ref 379 433
lost                            000104 automatic       char(6)                  level 4 packed packed unaligned dcl 89 set ref 488*
max                                                    builtin function         dcl 234 ref 733
max_header_size                 000413 automatic       fixed bin(17,0)          dcl 724 set ref 733* 735 737 739
mbuf                                   based           structure                level 1 dcl 167
mbuf_header                            based           structure                level 1 dcl 171 set ref 540* 733 739
mbuf_ptr                        000152 automatic       pointer                  dcl 108 set ref 417 424 425 486 487 525 529 530 538
                                                                                  540 739*
mess                     43(03)        based           bit(1)                   level 3 packed packed unaligned dcl 1-24 set ref
                                                                                  647*
message                  60            based           char(64)                 level 2 dcl 1-24 set ref 646*
message_len                     000154 automatic       fixed bin(21,0)          dcl 109 set ref 425 527 528* 535 538 728* 741* 744
                                                                                  746* 758 762 763 765* 765 771
min                                                    builtin function         dcl 234 ref 760
mmt                       4(18) 000104 automatic       picture(4)               level 4 packed packed unaligned dcl 89 set ref 430*
mod                                                    builtin function         dcl 234 ref 427 491 668 687
msg                       0(09)        based           char                     level 2 packed packed unaligned dcl 160 ref 763
multiply                                               builtin function         dcl 234 ref 564 575
n_data_pieces                   000155 automatic       fixed bin(17,0)          dcl 110 set ref 292* 294 305
nargs                           000156 automatic       fixed bin(17,0)          dcl 111 set ref 338* 347* 356* 364* 663
next                      5            based           bit(18)                  level 3 packed packed unaligned dcl 5-29 set ref
                                                                                  442* 461 463 503* 503
no_log                          000104 automatic       structure                level 3 in structure "auto_mbuf" dcl 89 in procedure
                                                                                  "syserr_real"
no_log                                 based           structure                level 3 in structure "mbuf" dcl 167 in procedure
                                                                                  "syserr_real" set ref 486 487
oc_entry                               based           structure                level 1 dcl 2-149
oc_event                               based           structure                level 1 dcl 2-241
oc_io                           000160 automatic       structure                level 1 dcl 112 set ref 586 586
oc_line_leng                    000160 automatic       fixed bin(17,0)          dcl 113 set ref 558* 560* 563*
oc_printed_leng                 000161 automatic       fixed bin(17,0)          dcl 114 set ref 564* 572* 572 573 574 575* 584
oc_trans_output_                000016 constant        entry                    external dcl 196 ref 563
ocdcm_$console_info             000020 constant        entry                    external dcl 197 ref 558
ocdcm_$drain_io                 000022 constant        entry                    external dcl 198 ref 607
ocdcm_$priority_io              000024 constant        entry                    external dcl 199 ref 586
ocdcm_code                      000162 automatic       fixed bin(35,0)          dcl 115 set ref 558* 560
ocdcm_init_flag           1(02)        based           bit(1)                   level 2 packed packed unaligned dcl 5-21 ref 417
old_mask                        000164 automatic       bit(72)                  dcl 116 set ref 378* 379
old_wlog                               based           bit(36)                  array dcl 185 set ref 441* 441
old_wlog_ptr                    000166 automatic       pointer                  dcl 117 set ref 408* 441 445 619 619*
olen                            000170 automatic       fixed bin(19,0)          dcl 118 set ref 563* 564 574* 575 583
optr                            000172 automatic       pointer                  dcl 119 set ref 549* 563*
out_buf                         000174 automatic       char(256)                dcl 120 set ref 549 572 573* 584
pad                       4(12) 000122 automatic       bit(24)                  level 2 in structure "auto_wmess_header" packed
                                                                                  packed unaligned dcl 93 in procedure "syserr_real"
                                                                                  set ref 397*
pad                       5(18) 000104 automatic       char(2)                  level 4 in structure "auto_mbuf" packed packed
                                                                                  unaligned dcl 89 in procedure "syserr_real" set
                                                                                  ref 431*
pad                       3(09) 000104 automatic       char(3)                  level 4 in structure "auto_mbuf" packed packed
                                                                                  unaligned dcl 89 in procedure "syserr_real" set
                                                                                  ref 490*
pds$apt_ptr                     000066 external static pointer                  dcl 220 ref 379
pds$process_group_id            000062 external static char(32)                 dcl 218 set ref 593* 605*
pds$processid                   000064 external static bit(36)                  dcl 219 ref 379 398 704 705
per_bootload             20            based           structure                level 2 dcl 6-11
pid                     116            based           bit(36)                  level 4 dcl 6-11 ref 379
piece_index                     000274 automatic       fixed bin(17,0)          dcl 121 set ref 294* 295* 305* 306 307*
pmut$bce_and_return             000026 constant        entry                    external dcl 200 ref 609 650
pmut$read_mask                  000030 constant        entry                    external dcl 201 ref 378
pmut$set_mask                   000032 constant        entry                    external dcl 202 ref 594
pmut$unwire_unmask              000034 constant        entry                    external dcl 203 ref 372 616
pmut$wire_and_mask              000036 constant        entry                    external dcl 204 ref 411
prds$                           000070 external static fixed bin(17,0)          dcl 221 set ref 379
prds$idle_ptr                   000072 external static pointer                  dcl 222 ref 379
prev_text_written         2            based           char(80)                 level 2 dcl 5-21 set ref 525 535 535* 538*
print_len                       000275 automatic       fixed bin(21,0)          dcl 122 set ref 425* 487* 487 527* 527 562 563* 571
                                                                                  580* 580
print_ptr                       000276 automatic       pointer                  dcl 123 set ref 424* 486* 529* 529 563* 579* 579
print_this_line_len             000300 automatic       fixed bin(21,0)          dcl 124 set ref 563* 571 579 580
process_id                5     000122 automatic       bit(36)                  level 2 dcl 93 set ref 398*
ptr                                    based           pointer                  array level 2 in structure "data_pieces_array"
                                                                                  dcl 155 in procedure "syserr_real" ref 307
ptr                                                    builtin function         dcl 234 in procedure "syserr_real" ref 461 753
pxss$unique_ring_0_wakeup       000040 constant        entry                    external dcl 205 ref 713
read                      6(01) 000160 automatic       bit(1)                   level 3 packed packed unaligned dcl 112 set ref 566*
rel                                                    builtin function         dcl 234 ref 442 753
rtb                      43            based           structure                level 2 dcl 1-24
rtime                           000302 automatic       fixed bin(71,0)          dcl 125 set ref 393* 396 427
rtrim                                                  builtin function         dcl 234 ref 572
scs$open_level                  000074 external static bit(72)                  dcl 223 set ref 379 594*
sd                                     based           structure                level 1 dcl 5-21
sd_ptr                          000332 automatic       pointer                  dcl 5-17 set ref 376* 379 417 433 525 535 535 538
                                                                                  697 697 704 705
segno                                                  builtin function         dcl 234 ref 756
seq_num                   1(18) 000104 automatic       picture(4)               level 4 in structure "auto_mbuf" packed packed
                                                                                  unaligned dcl 89 in procedure "syserr_real" set
                                                                                  ref 491*
seq_num                   4            based           fixed bin(35,0)          level 3 in structure "wlog" dcl 5-29 in procedure
                                                                                  "syserr_real" set ref 447 447* 481 481* 500 500*
seq_num                         000122 automatic       fixed bin(35,0)          level 2 in structure "auto_wmess_header" dcl 93
                                                                                  in procedure "syserr_real" set ref 433* 447* 481*
                                                                                  491 500* 568
sequence_no               7     000160 automatic       fixed bin(35,0)          level 2 dcl 112 set ref 568*
size                                                   builtin function         dcl 234 ref 463 733 733 733 737 737 738 739
stac                                                   builtin function         dcl 234 ref 705
stackbaseptr                                           builtin function         dcl 234 ref 379
stacq                                                  builtin function         dcl 234 ref 697
string                                                 builtin function         dcl 234 ref 425 487
substr                                                 builtin function         dcl 234 set ref 538 572 573* 584 745* 762* 763*
sys_code                        000304 automatic       fixed bin(17,0)          dcl 126 in procedure "syserr_real" set ref 379 379
                                                                                  390 391 484 493 592 599 668* 671 687*
sys_code                  3     000104 automatic       picture(1)               level 4 in structure "auto_mbuf" packed packed
                                                                                  unaligned dcl 89 in procedure "syserr_real" set
                                                                                  ref 493*
sys_info$time_correction_constant
                                000076 external static fixed bin(71,0)          dcl 224 ref 427
syserr                          000042 constant        entry                    external dcl 206 ref 664
syserr_copy$lock                000044 constant        entry                    external dcl 207 ref 407
syserr_copy$unlock              000046 constant        entry                    external dcl 208 ref 624
syserr_copy$wired_log           000050 constant        entry                    external dcl 209 ref 619 623
syserr_data$logger_ec           000100 external static fixed bin(71,0)          dcl 225 set ref 713*
syserr_data$logger_proc_id      000102 external static bit(36)                  dcl 226 set ref 713*
syserr_data$syserr_area         000110 external static char(1)                  dcl 5-14 set ref 376 633
syserr_data$wired_log_area      000112 external static char(1)                  dcl 5-14 set ref 401
syserr_data$wired_log_size      000104 external static fixed bin(17,0)          dcl 227 set ref 408* 441
syserr_log_data                        based           structure                level 1 dcl 6-11
syserr_log_data$                000114 external static fixed bin(17,0)          dcl 6-8 set ref 379
syserr_real$syserr_real         000052 constant        entry                    external dcl 210 ref 593 605
tenths_min                      000305 automatic       fixed bin(17,0)          dcl 127 set ref 427* 429 430 430
terminate_msg                   000005 constant        char(33)                 initial packed unaligned dcl 244 set ref 593*
terminate_proc                  000054 constant        entry                    external dcl 211 ref 595
termp_flags                     000001 constant        bit(1)                   initial array packed unaligned dcl 3-15 ref 379 592
text                     12     000160 automatic       char                     level 2 in structure "oc_io" dcl 112 in procedure
                                                                                  "syserr_real" set ref 584*
text                      6            based           char                     level 2 in structure "wmess" dcl 5-47 in procedure
                                                                                  "syserr_real" set ref 741 741 745* 762* 763*
text                      6            based           char(2047)               level 2 in structure "mbuf" packed packed unaligned
                                                                                  dcl 167 in procedure "syserr_real" set ref 417*
                                                                                  525 530 538
text_and_data_size              000414 automatic       fixed bin(17,0)          dcl 725 set ref 731* 735
text_len                  3(12)        based           fixed bin(11,0)          level 3 in structure "wmess" packed packed unaligned
                                                                                  dcl 5-47 in procedure "syserr_real" set ref 731
                                                                                  741 741 745 762 763 772
text_len                  3(12) 000122 automatic       fixed bin(11,0)          level 2 in structure "auto_wmess_header" packed
                                                                                  packed unaligned dcl 93 in procedure "syserr_real"
                                                                                  set ref 728* 758 771*
time                      4     000104 automatic       structure                level 3 in structure "auto_mbuf" dcl 89 in procedure
                                                                                  "syserr_real"
time                      4            based           structure                level 3 in structure "mbuf" dcl 167 in procedure
                                                                                  "syserr_real" set ref 424 425
time                      1     000122 automatic       fixed bin(71,0)          level 2 in structure "auto_wmess_header" packed
                                                                                  packed unaligned dcl 93 in procedure "syserr_real"
                                                                                  set ref 396*
unspec                                                 builtin function         dcl 234 set ref 535* 752* 752
wifnl_flags                     000000 constant        bit(1)                   initial array packed unaligned dcl 3-16 ref 484
wire_arg                        000306 automatic       bit(72)                  dcl 128 set ref 372* 411* 616*
wired                           000310 automatic       bit(1)                   dcl 129 set ref 368* 372 412*
wired_stack_ptr                 000316 automatic       pointer                  dcl 132 set ref 372* 411* 616*
wired_utility_$grow_stack_frame 000056 constant        entry                    external dcl 212 ref 408 735
wired_wlog_ptr                  000312 automatic       pointer                  dcl 130 set ref 401* 440 441 442 442 443 447 447 461
                                                                                  461 463 463 463 481 481 500 500 503 503 504 504
wired_wmess_ptr                 000314 automatic       pointer                  dcl 131 set ref 461* 507
wlog                                   based           structure                level 1 dcl 5-29
wlog_header                            based           structure                level 1 dcl 5-33 set ref 463 620* 733 737 738
wlog_ptr                        000334 automatic       pointer                  dcl 5-17 set ref 620 621 623* 737* 738
wmess                                  based           structure                level 1 dcl 5-47 set ref 731 772
wmess_copy                             based           bit(36)                  array dcl 188 set ref 507* 507
wmess_header                           based           structure                level 1 dcl 5-52 set ref 622* 733 737
wmess_len                       000320 automatic       fixed bin(17,0)          dcl 133 set ref 463 476* 476 503 507 772* 773
wmess_ptr                       000336 automatic       pointer                  dcl 5-17 set ref 506 507 622 738* 741 741 745 762
                                                                                  763 773
wordno                                                 builtin function         dcl 234 ref 463 529 529
work_ptr                        000416 automatic       pointer                  dcl 726 set ref 735* 737 739
write_flag                      000321 automatic       bit(1)                   dcl 134 set ref 390* 485* 520 548
write_flags                     000004 constant        bit(1)                   initial array packed unaligned dcl 3-12 ref 390

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALERT_DCW                              internal static fixed bin(17,0)          initial dcl 2-249
BEEP                                   internal static fixed bin(17,0)          initial dcl 4-7
CRASH                                  internal static fixed bin(17,0)          initial dcl 4-7
DISCARDED_OUTPUT                       internal static fixed bin(35,0)          initial dcl 2-262
DISCARD_DCW                            internal static fixed bin(17,0)          initial dcl 2-249
EVENT_QUEUE_SIZE                       internal static fixed bin(17,0)          initial dcl 2-313
FLAGBOX_SENTINEL                       internal static char(32)                 initial packed unaligned dcl 1-51
FREED_LOCK                             internal static fixed bin(35,0)          initial dcl 2-262
GOT_LOCK                               internal static fixed bin(35,0)          initial dcl 2-262
GOT_SPECIAL_INT                        internal static fixed bin(35,0)          initial dcl 2-262
INIT_OC_DATA                           internal static fixed bin(35,0)          initial dcl 2-262
IO_TIMEOUT                             internal static fixed bin(35,0)          initial dcl 2-262
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 4-7
LOCK_MCA_DCW                           internal static fixed bin(17,0)          initial dcl 2-249
LOCK_MCA_IO                            internal static fixed bin(35,0)          initial dcl 2-262
LOGGED_ERROR                           internal static fixed bin(35,0)          initial dcl 2-262
MAX_IMU_IO_TIME                        internal static fixed bin(17,0)          initial dcl 2-322
MAX_IO_TIME                            internal static fixed bin(17,0)          initial array dcl 2-326
MAX_MAX_IO_TIME                        internal static fixed bin(17,0)          initial dcl 2-351
MAX_OPC_CNT                            internal static fixed bin(17,0)          initial dcl 2-313
MAX_RETRIES                            internal static fixed bin(17,0)          initial dcl 2-313
MC_IO_FAILURE                          internal static fixed bin(35,0)          initial dcl 2-262
MC_IO_PICKUP                           internal static fixed bin(35,0)          initial dcl 2-262
NEWLINE_DCW                            internal static fixed bin(17,0)          initial dcl 2-249
POPPED_READ                            internal static fixed bin(35,0)          initial dcl 2-262
PRIORITY_OUTPUT                        internal static fixed bin(35,0)          initial dcl 2-262
PROMPT_DCW                             internal static fixed bin(17,0)          initial dcl 2-249
PUSHED_READ                            internal static fixed bin(35,0)          initial dcl 2-262
QUEUED_READ                            internal static fixed bin(35,0)          initial dcl 2-262
QUEUED_WRITE                           internal static fixed bin(35,0)          initial dcl 2-262
READ_DCW                               internal static fixed bin(17,0)          initial dcl 2-249
READ_NOT_IN_PROGRESS                   internal static fixed bin(35,0)          initial dcl 2-262
READ_PICKUP                            internal static fixed bin(35,0)          initial dcl 2-262
READ_UNECHOED_DCW                      internal static fixed bin(17,0)          initial dcl 2-249
RESET_CHANNEL                          internal static fixed bin(35,0)          initial dcl 2-262
RESET_DCW                              internal static fixed bin(17,0)          initial dcl 2-249
RETRY_IO                               internal static fixed bin(35,0)          initial dcl 2-262
SENT_ALERT                             internal static fixed bin(35,0)          initial dcl 2-262
SENT_MC_IO                             internal static fixed bin(35,0)          initial dcl 2-262
SENT_MC_PRIORITY_IO                    internal static fixed bin(35,0)          initial dcl 2-262
SENT_NEWLINE                           internal static fixed bin(35,0)          initial dcl 2-262
SENT_PROMPT                            internal static fixed bin(35,0)          initial dcl 2-262
SENT_WAKEUP                            internal static fixed bin(35,0)          initial dcl 2-262
STARTED_READ                           internal static fixed bin(35,0)          initial dcl 2-262
STARTED_UNECHOED_READ                  internal static fixed bin(35,0)          initial dcl 2-262
STARTED_WRITE                          internal static fixed bin(35,0)          initial dcl 2-262
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_DATA_V1                     internal static char(8)                  initial packed unaligned dcl 6-52
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 4-7
TERMINATED_ALERT                       internal static fixed bin(35,0)          initial dcl 2-262
TERMINATED_MCA_LOCK                    internal static fixed bin(35,0)          initial dcl 2-262
TERMINATED_MCA_UNLOCK                  internal static fixed bin(35,0)          initial dcl 2-262
TERMINATED_NEWLINE                     internal static fixed bin(35,0)          initial dcl 2-262
TERMINATED_PROMPT                      internal static fixed bin(35,0)          initial dcl 2-262
TERMINATED_READ                        internal static fixed bin(35,0)          initial dcl 2-262
TERMINATED_RESET                       internal static fixed bin(35,0)          initial dcl 2-262
TERMINATED_WRITE                       internal static fixed bin(35,0)          initial dcl 2-262
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 4-7
UNLOCK_MCA_DCW                         internal static fixed bin(17,0)          initial dcl 2-249
UNLOCK_MCA_IO                          internal static fixed bin(35,0)          initial dcl 2-262
WRITE_DCW                              internal static fixed bin(17,0)          initial dcl 2-249
WRITE_QUEUE_SIZE                       internal static fixed bin(17,0)          initial dcl 2-313
console_io_ptr                         automatic       pointer                  dcl 2-306
oc_data                                based           structure                level 1 dcl 2-90
oc_data$                               external static fixed bin(17,0)          dcl 2-88
oc_data_ptr                            automatic       pointer                  dcl 2-306
oc_data_version                        internal static char(4)                  initial packed unaligned dcl 2-303
oc_entry_ptr                           automatic       pointer                  dcl 2-306
oc_event_ptr                           automatic       pointer                  dcl 2-306
syserr_log_data_ptr                    automatic       pointer                  dcl 6-9

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000503 constant        label                    dcl 368 ref 257 279 311 328
RETRY_ADD                       001031 constant        label                    dcl 463 ref 478
SETUP_AND_TEXT                  002047 constant        entry                    internal dcl 717 ref 256 272 299 327
SR_LOCK                         001776 constant        entry                    internal dcl 701 ref 419
SR_UNLOCK                       001767 constant        entry                    internal dcl 694 ref 546
WAKEUP_DAEMON                   002025 constant        entry                    internal dcl 710 ref 510
binary                          000146 constant        entry                    external dcl 262
error_code                      000334 constant        entry                    external dcl 316
multiple_binary                 000217 constant        entry                    external dcl 284
panic                           001642 constant        entry                    external dcl 642 ref 417 704
ring0_setup                     001754 constant        entry                    internal dcl 680 ref 250 266 288 320
ring1                           000363 constant        entry                    external dcl 334
ring1_binary                    000431 constant        entry                    external dcl 352
ring1_error_code                000406 constant        entry                    external dcl 343
ring1_multiple_binary           000457 constant        entry                    external dcl 361
ring1_return                    001702 constant        label                    dcl 676 ref 665
ring1_setup                     001703 constant        entry                    internal dcl 656 ref 339 348 357 365
syserr_binary_start             000162 constant        label                    dcl 268 ref 358
syserr_error_start              000345 constant        label                    dcl 322 ref 349
syserr_multiple_binary_start    000233 constant        label                    dcl 290 ref 366
syserr_real                     000116 constant        entry                    external dcl 25
syserr_reset                    001626 constant        entry                    external dcl 630
syserr_start                    000127 constant        label                    dcl 252 ref 340

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3042        3160    2326        3052
Length      3556    2326       116         362     513           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
syserr_real                         382 external procedure  is an external procedure.  
on unit on line 370                  70 on unit               
ring1_setup                             internal procedure  shares stack frame of external procedure syserr_real.  
ring0_setup                             internal procedure  shares stack frame of external procedure syserr_real.  
SR_UNLOCK                               internal procedure  shares stack frame of external procedure syserr_real.  
SR_LOCK                                 internal procedure  shares stack frame of external procedure syserr_real.  
WAKEUP_DAEMON                           internal procedure  shares stack frame of external procedure syserr_real.  
SETUP_AND_TEXT                          internal procedure  shares stack frame of external procedure syserr_real.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
syserr_real              000100 alarm_flag                  syserr_real
                         000102 arg_list_ptr                syserr_real
                         000104 auto_mbuf                   syserr_real
                         000114 auto_wlog_header            syserr_real
                         000122 auto_wmess_header           syserr_real
                         000130 binary_call                 syserr_real
                         000131 code                        syserr_real
                         000132 cont_flag                   syserr_real
                         000133 copying_permitted           syserr_real
                         000134 cs_pos                      syserr_real
                         000135 data_code                   syserr_real
                         000136 data_len                    syserr_real
                         000137 data_piece_len              syserr_real
                         000140 data_piece_ptr              syserr_real
                         000142 data_pieces_array_ptr       syserr_real
                         000144 data_ptr                    syserr_real
                         000146 error_table_call            syserr_real
                         000147 error_table_code            syserr_real
                         000150 etmsgp                      syserr_real
                         000152 mbuf_ptr                    syserr_real
                         000154 message_len                 syserr_real
                         000155 n_data_pieces               syserr_real
                         000156 nargs                       syserr_real
                         000160 oc_line_leng                syserr_real
                         000160 oc_io                       syserr_real
                         000161 oc_printed_leng             syserr_real
                         000162 ocdcm_code                  syserr_real
                         000164 old_mask                    syserr_real
                         000166 old_wlog_ptr                syserr_real
                         000170 olen                        syserr_real
                         000172 optr                        syserr_real
                         000174 out_buf                     syserr_real
                         000274 piece_index                 syserr_real
                         000275 print_len                   syserr_real
                         000276 print_ptr                   syserr_real
                         000300 print_this_line_len         syserr_real
                         000302 rtime                       syserr_real
                         000304 sys_code                    syserr_real
                         000305 tenths_min                  syserr_real
                         000306 wire_arg                    syserr_real
                         000310 wired                       syserr_real
                         000312 wired_wlog_ptr              syserr_real
                         000314 wired_wmess_ptr             syserr_real
                         000316 wired_stack_ptr             syserr_real
                         000320 wmess_len                   syserr_real
                         000321 write_flag                  syserr_real
                         000330 fgbxp                       syserr_real
                         000332 sd_ptr                      syserr_real
                         000334 wlog_ptr                    syserr_real
                         000336 wmess_ptr                   syserr_real
                         000412 len_for_et                  SETUP_AND_TEXT
                         000413 max_header_size             SETUP_AND_TEXT
                         000414 text_and_data_size          SETUP_AND_TEXT
                         000416 work_ptr                    SETUP_AND_TEXT

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_in_desc    call_ext_out_desc   call_ext_out        return_mac          alloc_auto_adj      stac_mac
mdfx1               mdfx3               enable_op           ext_entry           ext_entry_desc      int_entry
divide_fx3          verify_for_rtrim    stacq_mac           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
arg_count_                    arg_list_ptr_                 formline_                     oc_trans_output_
ocdcm_$console_info           ocdcm_$drain_io               ocdcm_$priority_io            pmut$bce_and_return
pmut$read_mask                pmut$set_mask                 pmut$unwire_unmask            pmut$wire_and_mask
pxss$unique_ring_0_wakeup     syserr                        syserr_copy$lock              syserr_copy$unlock
syserr_copy$wired_log         syserr_real$syserr_real       terminate_proc
wired_utility_$grow_stack_frame

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$                 flagbox$                      pds$apt_ptr                   pds$process_group_id
pds$processid                 prds$                         prds$idle_ptr                 scs$open_level
sys_info$time_correction_constant                           syserr_data$logger_ec         syserr_data$logger_proc_id
syserr_data$syserr_area       syserr_data$wired_log_area    syserr_data$wired_log_size    syserr_log_data$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    112 000103        25 000113       249 000124       250 000126       252 000127       255 000130       256 000137
    257 000140       262 000141       265 000157       266 000161       268 000162       271 000165       272 000174
    273 000175       274 000177       275 000201       276 000203       279 000214       284 000215       287 000230
    288 000232       290 000233       292 000237       293 000241       294 000242       295 000251       296 000255
    298 000257       299 000266       301 000267       302 000271       303 000273       304 000275       305 000277
    306 000307       307 000314       308 000322       309 000325       311 000327       316 000330       319 000342
    320 000344       322 000345       324 000347       326 000350       327 000357       328 000360       334 000361
    337 000371       338 000373       339 000402       340 000403       343 000404       346 000414       347 000416
    348 000425       349 000426       352 000427       355 000442       356 000444       357 000453       358 000454
    361 000455       363 000470       364 000472       365 000501       366 000502       368 000503       370 000504
    372 000520       373 000533       374 000534       376 000535       378 000540       379 000546       390 000614
    391 000621       393 000625       395 000627       396 000632       397 000635       398 000637       399 000642
    401 000645       403 000647       407 000651       408 000655       411 000666       412 000677       417 000701
    419 000716       424 000717       425 000722       427 000725       429 000736       430 000747       431 000763
    433 000765       436 000773       440 000775       441 001000       442 001006       443 001011       444 001012
    445 001013       447 001015       448 001022       461 001023       463 001031       474 001047       475 001051
    476 001052       477 001060       478 001062       481 001063       484 001070       485 001075       486 001077
    487 001101       488 001103       489 001106       490 001110       491 001112       493 001125       495 001134
    500 001135       503 001142       504 001151       506 001152       507 001156       510 001164       520 001165
    525 001167       527 001177       528 001203       529 001205       530 001217       531 001227       533 001231
    535 001232       538 001242       540 001247       546 001253       548 001254       549 001256       550 001260
    558 001261       560 001311       562 001315       563 001320       564 001343       566 001346       567 001351
    568 001355       569 001357       571 001361       572 001364       573 001377       574 001403       575 001407
    579 001411       580 001415       581 001417       583 001420       584 001423       586 001430       587 001441
    592 001442       593 001447       594 001470       595 001477       596 001506       599 001507       605 001513
    607 001534       609 001541       616 001546       618 001557       619 001561       620 001573       621 001602
    622 001604       623 001610       624 001617       626 001624       630 001625       633 001634       635 001636
    642 001637       645 001656       646 001661       647 001667       649 001673       650 001674       651 001701
    676 001702       656 001703       659 001704       660 001705       661 001706       663 001707       664 001712
    665 001731       667 001732       668 001735       669 001740       670 001743       671 001750       673 001753
    680 001754       682 001755       683 001756       684 001757       686 001760       687 001763       688 001766
    694 001767       697 001770       699 001775       701 001776       704 001777       705 002013       706 002023
    707 002024       710 002025       713 002026       714 002046       717 002047       728 002050       729 002055
    731 002057       733 002073       735 002101       737 002114       738 002121       739 002124       741 002131
    744 002161       745 002163       746 002167       749 002171       750 002173       751 002175       752 002204
    753 002207       756 002222       758 002231       760 002236       761 002246       762 002250       763 002255
    765 002263       771 002265       772 002270       773 002304       774 002310


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
