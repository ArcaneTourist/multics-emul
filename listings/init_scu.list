	COMPILATION LISTING OF SEGMENT init_scu
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1027.8 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: style1 */
       10 
       11 init_scu: proc (P_tag, P_errtag, P_code);
       12 
       13 /* *	INIT_SCU - Initialize a System Controller.
       14*   *
       15*   *	History:
       16*   *	Modified 4/84, Keith Loepere for collection_1_phase.
       17*   *	Modified '82 for early initialization operation
       18*   *	Modified 01/09/81, W. Olin Sibert, for scs$scas_page_table.
       19*   *	Modified 12/01/79, Mike Grady, to improve mem config size checks.
       20*   *	Modified 07/14/79, Mike Grady, to improve config checks.
       21*   *	Modified sometime, BSG, for 8 cpu port expander.
       22*   *	Coded 03/01/76, Noel I. Morris
       23**/
       24 
       25 
       26 /****^  HISTORY COMMENTS:
       27*  1) change(88-07-27,Farley), approve(88-10-05,MCR7968),
       28*     audit(88-10-10,Beattie), install(88-10-14,MR12.2-1166):
       29*     Added code to check for memory address overlap conditions.  This adds a
       30*     call to pmut$check_for_mem_overlap and a new error code,
       31*     rcerr_addscu_memoverlap.
       32*                                                   END HISTORY COMMENTS */
       33 
       34 
       35 	dcl     P_tag		 fixed bin (3) parameter; /* system controller tag */
       36 	dcl     P_errtag		 fixed bin (3) parameter; /* CPU or mask in error */
       37 	dcl     P_code		 fixed bin (35) parameter; /* error code */
       38 
       39 	dcl     code		 fixed bin (35);	/* error code */
       40 	dcl     tag		 fixed bin (3);	/* tag of SCU we are working on */
       41 	dcl     ptp		 pointer;		/* Pointer to current SCAS PTW */
       42 	dcl     i			 fixed bin (3);	/* iteration index */
       43 	dcl     j			 fixed bin (3);	/* iteration index */
       44 	dcl     x			 fixed bin (5);	/* SCAS index */
       45 	dcl     low_base		 fixed bin;	/* for overlap check */
       46 	dcl     high_base		 fixed bin;	/* for overlap check */
       47 	dcl     mem_size		 fixed bin;	/* real mem size */
       48 	dcl     found		 bit (1) aligned;	/* used to check mask assignments */
       49 	dcl     unfound_mask	 (4) bit (1) unal;	/* used to check mask assignments also	*/
       50 
       51 	dcl     cdp		 ptr;
       52 	dcl     pdp		 ptr;
       53 	dcl     1 cdata		 based (cdp) like scs$controller_data aligned; /* single element of controller data */
       54 	dcl     1 pdata		 based (pdp) like scs$processor_data aligned; /* single element of processor data */
       55 
       56 	dcl     privileged_mode_ut$check_for_mem_overlap
       57 				 entry (fixed bin, fixed bin, fixed bin (35));
       58 	dcl     scr_util$read_cfg	 entry (fixed bin (3));
       59 	dcl     scr_util$set_mask	 entry (fixed bin (3), fixed bin (3), fixed bin (71));
       60 	dcl     syserr		 entry options (variable);
       61 
       62 	dcl     tag_letter		 (0:7) char (1) aligned static init ("A", "B", "C", "D", "E", "F", "G", "H"); /* for message */
       63 
       64 	dcl     (addr, bit, divide, index, string) builtin;
       65 
       66 
       67 	tag = P_tag;				/* Copy parameter */
       68 
       69 	cdp = addr (scs$controller_data (tag));		/* Get pointer to data for this controller. */
       70 	call set_scas_ptw ((tag), (cdata.base));	/* Set scas entry for this controller. */
       71 
       72 /* Read CFG data from the controller and fill in data pertaining to
       73*   the configuration of store units connected to the controller.	*/
       74 
       75 	call scr_util$read_cfg (tag);			/* Now, do RSCR CFG from controller. */
       76 
       77 	mem_size = cdata.lower_store_size + cdata.upper_store_size;
       78 
       79 	if cdata.size < mem_size then /* Processor and controller sizes disagree. */
       80 	     call init_error (rcerr_addscu_size, 0);
       81 
       82 	if scs$controller_config_size (tag) > mem_size then
       83 	     call init_error (rcerr_addscu_bigconfig, 0);
       84 
       85 	if ^cdata.program then /* Must be in programmable mode. */
       86 	     call init_error (rcerr_addscu_manual, 0);
       87 
       88 	if (cdata.type < "0010"b) & (string (scs$expanded_ports) ^= ""b) then
       89 	     call init_error (rcerr_addscu_oldexpand, 0); /* Can't have expanders on old SCU's */
       90 
       91 /* Set up any additional SCAS PTWs */
       92 
       93 	if (cdata.store_b_is_lower & cdata.store_a_online) |
       94 	     (^cdata.store_b_is_lower & cdata.store_b_online) then
       95 	     call set_scas_ptw (tag + 8, cdata.base + cdata.lower_store_size);
       96 
       97 	if (cdata.store_b_is_lower & cdata.store_b1_online) |
       98 	     (^cdata.store_b_is_lower & cdata.store_a1_online) then
       99 	     call set_scas_ptw (tag + 16, cdata.base + divide (cdata.lower_store_size, 2, 17, 0));
      100 
      101 	if (cdata.store_b_is_lower & cdata.store_a1_online) |
      102 	     (^cdata.store_b_is_lower & cdata.store_b1_online) then
      103 	     call set_scas_ptw (tag + 24, cdata.base + cdata.lower_store_size + divide (cdata.lower_store_size, 2, 17, 0));
      104 
      105 /**** Check for possible memory address overlap, which can occur when
      106*      stores A & A1 (and/or B & B1) should be enabled, but only A (and/or B)
      107*      is actually enabled. */
      108 
      109 						/** first check for overlap in lower store */
      110 
      111 	if (cdata.store_b_is_lower & cdata.store_b_online & ^cdata.store_b1_online) |
      112 	     (^cdata.store_b_is_lower & cdata.store_a_online & ^cdata.store_a1_online) then do;
      113 		low_base = cdata.base;
      114 		high_base = cdata.base + divide (cdata.lower_store_size, 2, 17, 0);
      115 		call privileged_mode_ut$check_for_mem_overlap
      116 		     (low_base, high_base, code);
      117 
      118 		if code ^= 0 then
      119 		     call init_error (rcerr_addscu_memoverlap, 0);
      120 	     end;
      121 
      122 						/** now check for overlap in lower store */
      123 
      124 	if (cdata.lower_store_size = cdata.upper_store_size) then
      125 	     if (cdata.store_b_is_lower & cdata.store_b_online & cdata.store_a_online & ^cdata.store_a1_online) |
      126 		(^cdata.store_b_is_lower & cdata.store_a_online & cdata.store_b_online & ^cdata.store_b1_online) then do;
      127 		     low_base = cdata.base + cdata.lower_store_size;
      128 		     high_base = cdata.base + cdata.lower_store_size +
      129 			divide (cdata.lower_store_size, 2, 17, 0);
      130 		     call privileged_mode_ut$check_for_mem_overlap
      131 			(low_base, high_base, code);
      132 
      133 		     if code ^= 0 then
      134 			call init_error (rcerr_addscu_memoverlap, 0);
      135 		end;
      136 
      137 
      138 /* Make sure that each assigned controller mask is assigned to
      139*   a processor, and that at most one controller mask is assigned
      140*   to each processor.					*/
      141 
      142 	string (unfound_mask) = "1111"b;		/* Mark all masks as not yet found. */
      143 
      144 	do i = 0 to 7;				/* Look at all CPU's. */
      145 	     pdp = addr (scs$processor_data (i));	/* Get pointer to data for this CPU. */
      146 	     if ^(pdata.offline | pdata.online) then /* Is CPU in the configuration ? */
      147 		goto NEXT_CPU_LOOP;
      148 
      149 	     found = "0"b;				/* Have not yet found mask for this processor. */
      150 	     do j = 1 to 4;				/* Look at all mask assignments. */
      151 		if cdata.eima_data (j).mask_assigned then do;
      152 			if pdata.controller_port = cdata.eima_data (j).mask_assignment then do;
      153 				if ^found then do;	/* Make sure neither mask nor port duplicates */
      154 					unfound_mask (j) = "0"b; /* Found a mask for this CPU. */
      155 					found = "1"b;
      156 					call scr_util$set_mask (tag, (pdata.controller_port), 0);
      157 				     end;
      158 
      159 				else call init_error (rcerr_addscu_dup_mask, i); /* Found more than one mask. */
      160 			     end;			/* Two masks are assigned to one port. */
      161 		     end;				/* Of case for assigned mask */
      162 
      163 		else unfound_mask (j) = "0"b;		/* No assignment for this mask. */
      164 	     end;					/* Of loop through possible masks */
      165 
      166 	     if (cdata.type < "0010"b) & ^found then /* If not 4MW SCU ... */
      167 		call init_error (rcerr_addscu_no_mask, i); /* Every processor must have an assigned mask. */
      168 
      169 NEXT_CPU_LOOP:
      170 	end;					/* Of loop through processors */
      171 
      172 	if string (unfound_mask) ^= ""b then /* If some mask not accounted for ... */
      173 	     call init_error (rcerr_addscu_bad_mask, (index (string (unfound_mask), "1"b) - 1));
      174 						/* Mask not assigned to a processor port. */
      175 
      176 	if ^(sys_info$collection_1_phase = EARLY_INITIALIZATION | sys_info$collection_1_phase > SERVICE_INITIALIZATION)
      177 	then if scs$controller_config_size (tag) < mem_size then
      178 		call syserr (0, "init_scu: Warning - Not all of MEM ^a will be used.", tag_letter (tag));
      179 
      180 	P_code = 0;				/* Indicate success */
      181 	P_errtag = 0;
      182 
      183 ERROR_RETURN:
      184 	return;					/* End of code for init_scu */
      185 
      186 
      187 final_scu: entry (P_tag);
      188 
      189 	tag = P_tag;				/* Copy parameter */
      190 
      191 	do x = tag by 8 while (x < 32);		/* Fault out all entries in SCAS for this controller. */
      192 	     call reset_scas_ptw (x);
      193 	end;
      194 
      195 	return;					/* End of code for init_scu$final_scu */
      196 
      197 
      198 init_error: proc (return_code, error_tag);
      199 
      200 	dcl     return_code		 fixed bin parameter;
      201 	dcl     error_tag		 fixed bin (3) parameter;
      202 
      203 
      204 	call final_scu (tag);			/* Finish this SCU */
      205 
      206 	P_code = return_code;			/* and return error parameters */
      207 	P_errtag = error_tag;
      208 
      209 	goto ERROR_RETURN;
      210      end init_error;
      211 
      212 
      213 
      214 set_scas_ptw: proc (scasx, base);			/* procedure to set PTW in scas. */
      215 
      216 	dcl     scasx		 fixed bin (5) parameter; /* index into the scas */
      217 	dcl     base		 fixed bin (14) parameter; /* absolute address (in 1024 word blocks) for PTW */
      218 
      219 
      220 	ptp = addr (scs$scas_page_table (scasx));	/* Find our PTW */
      221 
      222 	ptp -> l68_ptw.add = bit (base);		/* Insert base address in PTW. */
      223 	ptp -> l68_ptw.phu = "1"b;			/* Turn on used bit in PTW. */
      224 	ptp -> l68_ptw.valid = "1"b;			/* Turn off directed fault in PTW. */
      225 
      226 	return;
      227      end set_scas_ptw;
      228 
      229 
      230 
      231 reset_scas_ptw: proc (scasx);				/* proc to reset PTW in scas. */
      232 
      233 	dcl     scasx		 fixed bin (5) parameter; /* index into the scas */
      234 
      235 
      236 	ptp = addr (scs$scas_page_table (scasx));	/* Find our PTW */
      237 
      238 	ptp -> l68_ptw.valid = "0"b;			/* Turn on directed fault in PTW. */
      239 
      240 	return;
      241      end reset_scas_ptw;
      242 
      243  /* BEGIN include file collection_1_phases.incl.pl1 */
  1     2 
  1     3 /* Symbolic names for the various collection1 phases.
  1     4*Keith Loepere, October 1983. */
  1     5 
  1     6 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  1     7 
  1     8 dcl  sys_info$collection_1_phase	        fixed bin external static;
  1     9 
  1    10 dcl  EARLY_INITIALIZATION		        fixed bin init (1) static options (constant);  /* phase to find the config deck */
  1    11 dcl  BOOT_INITIALIZATION		        fixed bin init (2) static options (constant);  /* phase to setup up crash handler, bce */
  1    12 dcl  SERVICE_INITIALIZATION		        fixed bin init (3) static options (constant);  /* phase to set up for service */
  1    13 
  1    14 /* These first 3 (EARLY, BOOT and SERVICE) must be 1, 2, 3 in that order so
  1    15*programs can simply tell apart the booting phases from all others (crash or
  1    16*recovery type phases). */
  1    17 
  1    18 dcl  CRASH_INITIALIZATION		        fixed bin init (4) static options (constant);  /* phase to set up bce after crash/shut down */
  1    19 dcl  RE_EARLY_INITIALIZATION		        fixed bin init (5) static options (constant);  /* retry boot initialization given safe config to a new early level */
  1    20 dcl  BCE_CRASH_INITIALIZATION		        fixed bin init (6) static options (constant);  /* retry boot initialization to give a new boot level given a crash of bce */
  1    21 dcl  SHUT_INITIALIZATION		        fixed bin init (7) static options (constant);  /* same as boot but don't load new disk mpcs */
  1    22 
  1    23 dcl  COLLECTION_1_PHASE_NAMES		        (7) char (16) unal static options (constant) init
  1    24 				        ("early", "boot", "service", "crash", "re_early", "bce_crash", "shut");
  1    25 
  1    26 /* END include file collection_1_phases.incl.pl1 */
      243 
      244  /* BEGIN INCLUDE FILE scs.incl.pl1 ... March 1983 */
  2     2 /* format: style4 */
  2     3 
  2     4 /* Information about system controllers */
  2     5 
  2     6 dcl  1 scs$controller_data (0:7) aligned ext,		/* per-controller info */
  2     7        2 size fixed bin (17) unaligned,			/* size (in 1024 word blocks) of this controller */
  2     8        2 base fixed bin (17) unaligned,			/* abs address (0 mod 1024) for base of this controller */
  2     9        2 eima_data (4) unaligned,			/* EIMA information for this controller */
  2    10          3 mask_available bit (1) unaligned,		/* ON if corresponding mask exists */
  2    11          3 mask_assigned bit (1) unaligned,		/* ON if mask assigned to a port */
  2    12          3 mbz bit (3) unaligned,
  2    13          3 mask_assignment fixed bin (3) unaligned,	/* port to which mask is assigned */
  2    14        2 info aligned,
  2    15          3 online bit (1) unaligned,			/* ON if controller is online */
  2    16          3 offline bit (1) unaligned,			/* ON if controller is offline but can be added */
  2    17          3 store_a_online bit (1) unaligned,		/* ON if store A is online */
  2    18          3 store_a1_online bit (1) unaligned,		/* ON if store A1 is online */
  2    19          3 store_b_online bit (1) unaligned,		/* ON if store B is online */
  2    20          3 store_b1_online bit (1) unaligned,		/* ON if store B1 is online */
  2    21          3 store_b_is_lower bit (1) unaligned,		/* ON if store B is lower */
  2    22          3 ext_interlaced bit (1) unaligned,		/* ON if this SCU is interlaced with other SCU */
  2    23          3 int_interlaced bit (1) unaligned,		/* ON if this SCU is internally interlaced */
  2    24          3 four_word bit (1) unaligned,			/* ON if external interlace is 4-word */
  2    25          3 cyclic_priority (7) bit (1) unaligned,		/* Cyclic priority for adjacent ports */
  2    26          3 type bit (4) unaligned,			/* Model number for this controller */
  2    27          3 abs_wired bit (1) unaligned,			/* ON if controller can have abs_wired pages */
  2    28          3 program bit (1) unaligned,			/* PROGRAM/MANUAL switch setting */
  2    29          3 mbz bit (13) unaligned,
  2    30        2 lower_store_size fixed bin (17) unaligned,	/* size (in 1024 word blocks) of lower store */
  2    31        2 upper_store_size fixed bin (17) unaligned;	/* size (in 1024 word blocks) of upper store */
  2    32 
  2    33 /* Information about CPUs */
  2    34 
  2    35 dcl  1 scs$processor_data (0:7) aligned ext,		/* information about CPUs in the system */
  2    36        (
  2    37        2 online bit (1),				/* "1"b if CPU is online */
  2    38        2 offline bit (1),				/* "1"b if CPU is offline but can be added */
  2    39        2 release_mask bit (1),			/* "1"b is this CPU is to give up its mask */
  2    40        2 accept_mask bit (1),				/* "1"b if this CPU is to grap mask in idle loop */
  2    41        2 delete_cpu bit (1),				/* "1"b if this CPU is to delete itself */
  2    42        2 interrupt_cpu bit (1),			/* "1"b if this CPU takes hardware interrupts */
  2    43        2 halted_cpu bit (1),				/* "1"b if this CPU has stopped itself (going to BOS) */
  2    44        2 cpu_type fixed bin (2) unsigned,		/*  0 => DPS or L68, 1 => DPS8 */
  2    45        2 mbz1 bit (6),
  2    46        2 cache_size fixed bin (3) unsigned,		/* 0 = No cache; 1 = L68 2K cache;
  2    47*						   2 = DPS8 8K cache; 3 = DPS8 VS&SC 8K cache;
  2    48*						   4 = DPS8 VS&SC 16K cache; 5 = DPS8 VS&SC 32K cache
  2    49*						   7 = ignore cache size (set by ISOLTS reconfig) */
  2    50        2 mbz2 bit (12),
  2    51        2 expanded_port bit (1),			/* "1"b = on expanded port */
  2    52        2 expander_port fixed bin (2) unsigned,		/* The actual expander port */
  2    53        2 controller_port fixed bin (3) unsigned
  2    54        ) unaligned;					/* Port on controller */
  2    55 
  2    56 dcl  1 scs$port_data (0:7) aligned external static,	/* Info about what is connected to each SCU port */
  2    57        2 assigned fixed bin (4) unsigned unaligned,	/* Type of device on this port		*/
  2    58        2 expander_port bit (1) unaligned,		/* "1"b => this port has a port expander */
  2    59        2 expanded_cpu (0:3) bit (1) unaligned,		/* "1"b => this expander port has a CPU attached */
  2    60        2 iom_number fixed bin (3) unsigned unaligned,	/* IOM number of IOM attached to this port */
  2    61        2 cpu_number (0:3) fixed bin (3) unsigned unaligned, /* CPU number of CPU(s) attached to this port */
  2    62 						/* cpu_number (0) is only one if expander_port is "0"b */
  2    63        2 pad bit (12) unaligned;
  2    64 
  2    65 dcl  1 scs$cow (0:7) aligned external,			/* Actual connect words */
  2    66        2 pad bit (36) aligned,			/* Expander COW's must be odd-word */
  2    67        2 cow,
  2    68          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  2    69          3 mbz1 bit (13) unaligned,
  2    70          3 expander_command bit (3) unaligned,		/* Expander command. */
  2    71          3 mbz2 bit (2) unaligned,
  2    72          3 expanded_port bit (1) unaligned,		/* "1"b = on expanded port */
  2    73          3 expander_port fixed bin (3) unsigned unaligned,	/* Port on expander for cioc */
  2    74          3 mbz3 bit (3) unaligned,
  2    75          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  2    76 
  2    77 dcl  1 scs$cow_ptrs (0:7) external aligned,		/* Pointers to COW's */
  2    78        2 rel_cow_ptr bit (18) unal,			/* Relative pointer to COW */
  2    79        2 pad bit (12) unal,
  2    80        2 tag bit (6) unal;				/* Better be zero. */
  2    81 
  2    82 dcl  1 scs$reconfig_general_cow aligned external,		/* Used during reconfig ops. */
  2    83        2 pad bit (36) aligned,
  2    84        2 cow,					/* Connect operand word, in odd location. */
  2    85          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  2    86          3 mbz1 bit (13) unaligned,
  2    87          3 expander_command bit (3) unaligned,		/* Expander command. */
  2    88          3 mbz2 bit (9) unaligned,
  2    89          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  2    90 
  2    91 /* MASKS and PATTERNS */
  2    92 
  2    93 dcl  scs$sys_level bit (72) aligned ext;		/* mask used while handling I/O interrupts */
  2    94 dcl  scs$open_level bit (72) aligned ext;		/* mask used during normal operation */
  2    95 dcl  scs$processor_start_mask bit (72) aligned ext;	/* mask used when starting up a CPU */
  2    96 dcl  scs$cpu_test_mask bit (72) aligned ext;		/* mask used for ISOLTS CPU testing */
  2    97 dcl  scs$number_of_masks fixed bin ext;			/* number of masks (starting at sys_level) */
  2    98 dcl  scs$processor_start_pattern bit (36) aligned ext;	/* SMIC pattern used to send processor start interrupt */
  2    99 dcl  scs$cpu_test_pattern bit (36) aligned ext;		/* SMIC pattern used for ISOLTS processor testing */
  2   100 
  2   101 /* CAM and CACHE clear info */
  2   102 
  2   103 dcl  scs$cam_pair fixed bin (71) ext;			/* instructions XEDd when CAMing and clearing CACHE */
  2   104 dcl  scs$cam_wait bit (8) aligned ext;			/* Used when evicting pages from main memory */
  2   105 
  2   106 /* MASKING INSTRUCTIONS & POINTERS */
  2   107 
  2   108 dcl  scs$set_mask (0:7) bit (36) aligned ext;		/* instructions to set mask (STAQ or SMCM) */
  2   109 dcl  scs$read_mask (0:7) bit (36) aligned ext;		/* instructions to read mask (LDAQ or RMCM) */
  2   110 dcl  scs$mask_ptr (0:7) ptr unaligned ext;		/* pointers for real or simulated masks */
  2   111 
  2   112 /* MISCELLANEOUS */
  2   113 
  2   114 dcl  1 scs$processor_test_data aligned ext,		/* info used for cpu testing */
  2   115        (
  2   116        2 active bit (1),				/* = "1"b if cpu currently under test */
  2   117        2 scu_state bit (2),				/* state of scu being used for testing (see definition below) */
  2   118        2 pad1 bit (4),
  2   119        2 req_mem fixed bin (10),			/* dedicated memory required to test this cpu */
  2   120        2 cpu_tag fixed bin (5),			/* tag of cpu under test */
  2   121        2 scu_tag fixed bin (5),			/* tag of scu being used for cpu testing */
  2   122        2 mask_cpu fixed bin (5)
  2   123        ) unaligned;					/* tag of active cpu that has mask asigned to above scu */
  2   124 
  2   125 /* scu_state = "00"b => SCU defined by scs$processor_test_data.scu_tag not yet effected */
  2   126 /* scu_state = "01"b => all core removed from SCU, port mask not yet changed */
  2   127 /* scu_state = "10"b => all core removed from SCU, port mask changed */
  2   128 /* scu_state = "11"b => only 64k at base of SCU being used for testing, original port mask restored */
  2   129 
  2   130 dcl  scs$idle_aptep (0:7) ptr unaligned ext;		/* pointer to idle process APTE for each processor */
  2   131 
  2   132 dcl  scs$connect_lock bit (36) aligned ext;		/* lock for sending connects */
  2   133 dcl  scs$reconfig_lock bit (36) aligned ext;		/* Lock used during reconfiguration */
  2   134 dcl  scs$trouble_flags bit (8) aligned ext;		/* checkoff flags for sys_trouble stopping */
  2   135 dcl  scs$bos_restart_flags bit (8) aligned ext;		/* checkoff flags for restarting after sys_trouble */
  2   136 dcl  scs$nprocessors fixed bin ext;			/* number of runnung processors */
  2   137 dcl  scs$bos_processor_tag fixed bin (3) ext;		/* CPU tag of processor running BOS */
  2   138 dcl  scs$faults_initialized bit (1) aligned ext;		/* ON after faults have been enabled */
  2   139 dcl  scs$sys_trouble_pending bit (1) aligned ext;		/* sys_trouble event is pending in the system */
  2   140 dcl  scs$fast_cam_pending (0:7) bit (36) aligned ext;	/* checkoff cells for cam connect		*/
  2   141 dcl  scs$interrupt_controller fixed bin (3) ext;		/* port number of low order controller */
  2   142 dcl  scs$processor_start_int_no fixed bin (5) ext;	/* interrupt cell for starting a processor */
  2   143 dcl  scs$processor bit (8) aligned ext;			/* bits ON for online CPUs */
  2   144 dcl  scs$processor_start_wait bit (8) aligned ext;	/* checkoff flags for waiting for new processor */
  2   145 
  2   146 dcl  scs$trouble_dbrs (0:7) fixed bin (71);		/* DBR values at system crash time */
  2   147 
  2   148 dcl  scs$port_addressing_word (0:7) bit (3) aligned ext;	/* active module port number for each controller */
  2   149 
  2   150 dcl  scs$cfg_data (0:7) fixed bin (71) aligned ext;	/* RSCR-CFG data from each controller */
  2   151 
  2   152 dcl  scs$cfg_data_save fixed bin (71) aligned ext;	/* RSCR-CFG save area for ISOLTS CPU testing */
  2   153 
  2   154 dcl  scs$expanded_ports bit (1) unaligned dim (0:7) external;
  2   155 						/* Which ports have expanders */
  2   156 
  2   157 dcl  scs$processor_switch_data (0:4) bit (36) aligned ext;	/* raw data from RSW 0 thru 4 */
  2   158 dcl  scs$processor_switch_template (0:4) bit (36) aligned ext; /* expected data from RSW 0 thru 4 */
  2   159 dcl  scs$processor_switch_compare (0:4) bit (36) aligned ext; /* discrepancies from expected data */
  2   160 dcl  scs$processor_switch_mask (0:4) bit (36) aligned ext;	/* masks for comparing switch data */
  2   161 
  2   162 dcl  scs$processor_data_switch_value bit (36) aligned ext;	/* Correct value for CPU data switches */
  2   163 
  2   164 dcl  scs$controller_config_size (0:7) fixed bin (14) aligned ext;
  2   165 						/* Controller size on config card */
  2   166 
  2   167 dcl  scs$reconfig_locker_id char (32) aligned ext;	/* process group ID of process doing reconfiguration */
  2   168 
  2   169 dcl  scs$scas_page_table (0:31) bit (36) aligned external static;
  2   170 						/* PTWs for SCAS pages */
  2   171 
  2   172 dcl  scs$cycle_priority_template bit (7) aligned ext;	/* template for setting anti-hog switches	*/
  2   173 dcl  scs$set_cycle_switches bit (1) aligned ext;		/* flag to set ant-hog switches		*/
  2   174 
  2   175 
  2   176 dcl  (
  2   177      IOM_PORT init (1),
  2   178      CPU_PORT init (2),
  2   179      BULK_PORT init (3)
  2   180      ) fixed bin int static options (constant);		/* values for scs$port_data.assigned		*/
  2   181 
  2   182 
  2   183 /* END INCLUDE FILE scs.incl.pl1 */
      244 
      245  /* BEGIN INCLUDE FILE ... ptw.l68.incl.pl1 ... 02/26/81, for ADP conversion */
  3     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  3     3 
  3     4 dcl 1 l68_core_ptw aligned based (ptp), 		/* In-core page descriptor */
  3     5     2 frame fixed bin (14) unsigned unaligned,		/* Core frame number */
  3     6     2 pad1 bit (4) unaligned,
  3     7     2 flags unaligned like l68_ptw_flags;
  3     8 
  3     9 dcl 1 l68_ptw aligned based (ptp),			/* General declaration for out-of-core PTW */
  3    10     2 add bit (18) unaligned,
  3    11     2 flags like l68_ptw_flags unaligned;
  3    12 
  3    13 dcl 1 l68_special_ptw aligned based (ptp) like l68_ptw;	/* Page is somewhere peculiar -- add_type = "01"b */
  3    14 dcl 1 l68_real_disk_ptw aligned based (ptp) like l68_ptw;	/* PTW for page actually on disk -- add_type = "10"b */
  3    15 dcl 1 l68_null_disk_ptw aligned based (ptp) like l68_ptw;	/* PTW for page not yet on disk -- add_type = "11"b */
  3    16 
  3    17 dcl 1 l68_ptw_flags unaligned based,			/* Various software/hardware flags */
  3    18    (2 add_type bit (4),				/* 0000=null, 1000=core, 0100=disk, 0010=pd, 0001=swap */
  3    19     2 first bit (1),				/* the page has not yet been written out */
  3    20     2 er bit (1),					/* error on last page I/O (also used by post-purge as temp) */
  3    21 
  3    22     2 pad1 bit (1),
  3    23     2 unusable1 bit (1),				/* can't be used because hardware resets this bit */
  3    24     2 phu bit (1),					/* page has been used bit */
  3    25 
  3    26     2 phm1 bit (1), 				/* Cumulative OR of hardware phm's */
  3    27     2 nypd bit (1), 				/* must be moved to paging device */
  3    28     2 phm bit (1),					/* page has been modified bit */
  3    29 
  3    30     2 phu1 bit (1), 				/* page has been used in the quantum */
  3    31     2 wired bit (1),				/* page is to remain in core */
  3    32     2 os bit (1),					/* page is out-of-service (I/O in progress) */
  3    33     2 valid bit (1),				/* directed fault if this is 0 (page not in core) */
  3    34     2 df_no bit (2)) unaligned;			/* directed fault number for page faults */
  3    35 
  3    36 /* END INCLUDE FILE ... ptw.l68.incl.pl1 */
      245 
      246  
  4     2 /* Begin include file ...... rcerr.incl.pl1 */
  4     3 /* These are the reconfiguration error codes. */
  4     4 /*	Created 4/5/76 by Noel I. Morris	*/
  4     5 /* Modified 5/25/78 by J. A. Bush to add ISOLTS  reconfig error codes */
  4     6 /* Modified 5/79 by BSG for port expander */
  4     7 
  4     8 
  4     9 /****^  HISTORY COMMENTS:
  4    10*  1) change(88-07-27,Farley), approve(88-10-05,MCR7968),
  4    11*     audit(88-10-10,Beattie), install(88-10-14,MR12.2-1166):
  4    12*     Added new rcerr_addscu_memoverlap error code.
  4    13*                                                   END HISTORY COMMENTS */
  4    14 
  4    15 
  4    16 dcl (rcerr_addcpu_no_response init (1),			/* no response from CPU */
  4    17      rcerr_addcpu_bad_switches init (2),		/* CPU config switches set improperly */
  4    18      rcerr_addcpu_trouble init (3),			/* trouble fault adding CPU */
  4    19      rcerr_addcpu_startup init (4),			/* startup fault adding CPU */
  4    20      rcerr_addcpu_lockup init (5),			/* lockup fault adding CPU */
  4    21      rcerr_addcpu_gcos init (6),			/* attempt to add processor in GCOS mode */
  4    22      rcerr_addcpu_amoff init (7),			/* attempt to add processor with assoc mem off */
  4    23      rcerr_addcpu_enable init (8)			/* controller port for CPU not enabled */
  4    24      ) fixed bin static options (constant);
  4    25 
  4    26 dcl (rcerr_delcpu_no_stop init (1),			/* CPU did not stop running */
  4    27      rcerr_delcpu_last init (2),			/* attempt to delete last CPU */
  4    28      rcerr_delcpu_no_good_blcpu init (3)		/* no suitable bootload CPU left */
  4    29      ) fixed bin static options (constant);
  4    30 
  4    31 dcl (rcerr_addscu_size init (1),			/* memory size discrepancy */
  4    32      rcerr_addscu_dup_mask init (2),			/* duplicate mask assignment */
  4    33      rcerr_addscu_no_mask init (3),			/* no mask assigned to CPU */
  4    34      rcerr_addscu_bad_mask init (4),			/* mask assigned to non-CPU port */
  4    35      rcerr_addscu_fault init (5),			/* fault trying to add controller */
  4    36      rcerr_addscu_switches init (6),			/* some active module has incorrect switches */
  4    37      rcerr_addscu_enable init (7),			/* some active module not enabled */
  4    38      rcerr_addscu_manual init (8),			/* 4MW SCU is in manual mode */
  4    39      rcerr_addscu_oldexpand init (9),			/* Adding 6000 SCU with port expander */
  4    40      rcerr_addscu_bigconfig init (10),			/* SCU has less memory than config cards say */
  4    41      rcerr_addscu_memoverlap init (11)			/* SCU has possible memory address overlap */
  4    42      ) fixed bin static options (constant);
  4    43 
  4    44 dcl (rcerr_delmain_nomem init (1),			/* not enough main memory left */
  4    45      rcerr_delmain_abs_wired init (2)			/* abs wired pages in memory */
  4    46      ) fixed bin static options (constant);
  4    47 
  4    48 dcl (rcerr_locked init (12),				/* database already locked */
  4    49      rcerr_online init (13),				/* device already online */
  4    50      rcerr_no_config init (14),			/* device not in configuration */
  4    51      rcerr_not_online init (15),			/* device not online */
  4    52      rcerr_range init (16),				/* request is out of range */
  4    53      rcerr_sprq_failed init (17)			/* could not set CPU required */
  4    54 
  4    55      ) fixed bin static options (constant);
  4    56 
  4    57 dcl (rcerr_isolts_locked init (1),			/* reconfig_lock locked to another process */
  4    58      rcerr_isolts_illegal_cpu init (2),			/* illegal cpu tag */
  4    59      rcerr_isolts_cpu_online init (3),			/* requested cpu is online */
  4    60      rcerr_isolts_no_config init (4),			/* requested cpu is not configured */
  4    61      rcerr_isolts_two_scu init (5),			/* Must have at least two SCUs to run ISOLTS */
  4    62      rcerr_isolts_illegal_scu init (6),			/* illegal scu tag */
  4    63      rcerr_isolts_bootload_scu init (7),		/* requested scu is the bootload memory */
  4    64      rcerr_isolts_scu_not init (8),			/* requested scu is not configured */
  4    65      rcerr_isolts_not init (9),			/* requesting process is not ISOLTS process */
  4    66      rcerr_isolts_wrong_cell init (10),			/* interrupt answered in correct scu but wrong cell */
  4    67      rcerr_isolts_wrong_scu init (11),			/* interrupt answered in wrong scu */
  4    68      rcerr_isolts_wrong_scu_cell init (12),		/* interrupt answered in wrong scu on wrong cell */
  4    69      rcerr_isolts_no_response init (13),		/* No response to a processor start interrupt */
  4    70      rcerr_isolts_bad_switches init (14),		/* read switch data is not in expected format */
  4    71      rcerr_isolts_lda_fail init (15),			/* A LDA 2 did not operate correctly */
  4    72      rcerr_isolts_no_str_flt init (16),			/* No store falt when a LDA 64k was executed */
  4    73      rcerr_isolts_no_mask init (17)			/* No mask set for test cpu */
  4    74      ) fixed bin static options (constant);
  4    75 
  4    76 dcl 1 switch_w1 aligned based,			/* template for switch word 1, when containing diagnostic info */
  4    77    (2 cell fixed bin (5),				/* interrupt cell being used */
  4    78     2 errtag fixed bin (5),				/* tag of scu in error */
  4    79     2 valid bit (1),				/* if on then offset field is valid */
  4    80     2 pad bit (5),
  4    81     2 offset bit (18)) unaligned;			/* offset of error if any */
  4    82 
  4    83 /* End of include file ...... rcerr.incl.pl1 */
  4    84 
      246 
      247 
      248 
      249 /* BEGIN MESSAGE DOCUMENTATION
      250*
      251*   Message:
      252*   init_scu: Warning - Not all of MEM Y will be used.
      253*
      254*   S:	$info
      255*
      256*   T:	$init
      257*
      258*   M:	The actual amount of memory present in MEM Y does
      259*   not agree with the config deck. Only as much as the configuration deck
      260*   specifies will be used.
      261*
      262*   A:	If this is an unintentional error,
      263*   correct the configuration deck before the next bootload.
      264*
      265*
      266*   END MESSAGE DOCUMENTATION */
      267 
      268      end init_scu;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0825.5  init_scu.pl1                      >special_ldd>install>MR12.3-1114>init_scu.pl1
243          1    07/11/84  0937.3  collection_1_phases.incl.pl1      >ldd>include>collection_1_phases.incl.pl1
244          2    10/12/83  0943.5  scs.incl.pl1                      >ldd>include>scs.incl.pl1
245          3    03/27/82  0430.2  ptw.l68.incl.pl1                  >ldd>include>ptw.l68.incl.pl1
246          4    10/18/88  1206.7  rcerr.incl.pl1                    >ldd>include>rcerr.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
EARLY_INITIALIZATION                   constant        fixed bin(17,0)          initial dcl 1-10 ref 176
P_code                                 parameter       fixed bin(35,0)          dcl 37 set ref 11 180* 206*
P_errtag                               parameter       fixed bin(3,0)           dcl 36 set ref 11 181* 207*
P_tag                                  parameter       fixed bin(3,0)           dcl 35 ref 11 67 187 189
SERVICE_INITIALIZATION                 constant        fixed bin(17,0)          initial dcl 1-12 ref 176
add                                    based           bit(18)                  level 2 packed packed unaligned dcl 3-9 set ref 222*
addr                                                   builtin function         dcl 64 ref 69 145 220 236
base                      0(18)        based           fixed bin(17,0)          level 2 in structure "cdata" packed packed unaligned
                                                                                  dcl 53 in procedure "init_scu" ref 70 93 97 101
                                                                                  113 114 127 128
base                                   parameter       fixed bin(14,0)          dcl 217 in procedure "set_scas_ptw" ref 214 222
bit                                                    builtin function         dcl 64 ref 222
cdata                                  based           structure                level 1 dcl 53
cdp                             000114 automatic       pointer                  dcl 51 set ref 69* 70 77 77 79 85 88 93 93 93 93 93
                                                                                  93 97 97 97 97 97 97 101 101 101 101 101 101 101
                                                                                  111 111 111 111 111 111 113 114 114 124 124 124
                                                                                  124 124 124 124 124 124 124 127 127 128 128 128
                                                                                  151 152 166
code                            000100 automatic       fixed bin(35,0)          dcl 39 set ref 115* 118 130* 133
controller_port           0(33)        based           fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 54 ref
                                                                                  152 156
divide                                                 builtin function         dcl 64 ref 97 101 114 128
eima_data                 1            based           structure                array level 2 packed packed unaligned dcl 53
error_tag                              parameter       fixed bin(3,0)           dcl 201 ref 198 207
flags                     0(18)        based           structure                level 2 packed packed unaligned dcl 3-9
found                           000112 automatic       bit(1)                   dcl 48 set ref 149* 153 155* 166
high_base                       000110 automatic       fixed bin(17,0)          dcl 46 set ref 114* 115* 128* 130*
i                               000104 automatic       fixed bin(3,0)           dcl 42 set ref 144* 145 159* 166*
index                                                  builtin function         dcl 64 ref 172
info                      2            based           structure                level 2 dcl 53
j                               000105 automatic       fixed bin(3,0)           dcl 43 set ref 150* 151 152 154 163*
l68_ptw                                based           structure                level 1 dcl 3-9
l68_ptw_flags                          based           structure                level 1 packed packed unaligned dcl 3-17
low_base                        000107 automatic       fixed bin(17,0)          dcl 45 set ref 113* 115* 127* 130*
lower_store_size          3            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 53 ref 77 93 97
                                                                                  101 101 114 124 127 128 128
mask_assigned             1(01)        based           bit(1)                   array level 3 packed packed unaligned dcl 53 ref 151
mask_assignment           1(05)        based           fixed bin(3,0)           array level 3 packed packed unaligned dcl 53 ref 152
mem_size                        000111 automatic       fixed bin(17,0)          dcl 47 set ref 77* 79 82 176
offline                   0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 54 ref 146
online                                 based           bit(1)                   level 2 packed packed unaligned dcl 54 ref 146
pdata                                  based           structure                level 1 dcl 54
pdp                             000116 automatic       pointer                  dcl 52 set ref 145* 146 146 152 156
phu                       0(26)        based           bit(1)                   level 3 packed packed unaligned dcl 3-9 set ref 223*
privileged_mode_ut$check_for_mem_overlap
                                000020 constant        entry                    external dcl 56 ref 115 130
program                   2(22)        based           bit(1)                   level 3 packed packed unaligned dcl 53 ref 85
ptp                             000102 automatic       pointer                  dcl 41 set ref 220* 222 223 224 236* 238
rcerr_addscu_bad_mask                  constant        fixed bin(17,0)          initial dcl 4-31 set ref 172*
rcerr_addscu_bigconfig          000001 constant        fixed bin(17,0)          initial dcl 4-31 set ref 82*
rcerr_addscu_dup_mask                  constant        fixed bin(17,0)          initial dcl 4-31 set ref 159*
rcerr_addscu_manual                    constant        fixed bin(17,0)          initial dcl 4-31 set ref 85*
rcerr_addscu_memoverlap         000000 constant        fixed bin(17,0)          initial dcl 4-31 set ref 118* 133*
rcerr_addscu_no_mask                   constant        fixed bin(17,0)          initial dcl 4-31 set ref 166*
rcerr_addscu_oldexpand                 constant        fixed bin(17,0)          initial dcl 4-31 set ref 88*
rcerr_addscu_size                      constant        fixed bin(17,0)          initial dcl 4-31 set ref 79*
return_code                            parameter       fixed bin(17,0)          dcl 200 ref 198 206
scasx                                  parameter       fixed bin(5,0)           dcl 216 in procedure "set_scas_ptw" ref 214 220
scasx                                  parameter       fixed bin(5,0)           dcl 233 in procedure "reset_scas_ptw" ref 231 236
scr_util$read_cfg               000022 constant        entry                    external dcl 58 ref 75
scr_util$set_mask               000024 constant        entry                    external dcl 59 ref 156
scs$controller_config_size      000040 external static fixed bin(14,0)          array dcl 2-164 ref 82 176
scs$controller_data             000032 external static structure                array level 1 dcl 2-6 set ref 69
scs$expanded_ports              000036 external static bit(1)                   array packed unaligned dcl 2-154 ref 88
scs$processor_data              000034 external static structure                array level 1 dcl 2-35 set ref 145
scs$scas_page_table             000042 external static bit(36)                  array dcl 2-169 set ref 220 236
size                                   based           fixed bin(17,0)          level 2 packed packed unaligned dcl 53 ref 79
store_a1_online           2(03)        based           bit(1)                   level 3 packed packed unaligned dcl 53 ref 97 101
                                                                                  111 124
store_a_online            2(02)        based           bit(1)                   level 3 packed packed unaligned dcl 53 ref 93 111
                                                                                  124 124
store_b1_online           2(05)        based           bit(1)                   level 3 packed packed unaligned dcl 53 ref 97 101
                                                                                  111 124
store_b_is_lower          2(06)        based           bit(1)                   level 3 packed packed unaligned dcl 53 ref 93 93 97
                                                                                  97 101 101 111 111 124 124
store_b_online            2(04)        based           bit(1)                   level 3 packed packed unaligned dcl 53 ref 93 111
                                                                                  124 124
string                                                 builtin function         dcl 64 set ref 88 142* 172 172
sys_info$collection_1_phase     000030 external static fixed bin(17,0)          dcl 1-8 ref 176 176
syserr                          000026 constant        entry                    external dcl 60 ref 176
tag                             000101 automatic       fixed bin(3,0)           dcl 40 set ref 67* 69 70 75* 82 93 97 101 156* 176
                                                                                  176 189* 191 204*
tag_letter                      000010 internal static char(1)                  initial array dcl 62 set ref 176*
type                      2(17)        based           bit(4)                   level 3 packed packed unaligned dcl 53 ref 88 166
unfound_mask                    000113 automatic       bit(1)                   array packed unaligned dcl 49 set ref 142* 154* 163*
                                                                                  172 172
upper_store_size          3(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 53 ref 77 124
valid                     0(33)        based           bit(1)                   level 3 packed packed unaligned dcl 3-9 set ref 224*
                                                                                  238*
x                               000106 automatic       fixed bin(5,0)           dcl 44 set ref 191* 191* 192*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BCE_CRASH_INITIALIZATION               internal static fixed bin(17,0)          initial dcl 1-20
BOOT_INITIALIZATION                    internal static fixed bin(17,0)          initial dcl 1-11
BULK_PORT                              internal static fixed bin(17,0)          initial dcl 2-176
COLLECTION_1_PHASE_NAMES               internal static char(16)                 initial array packed unaligned dcl 1-23
CPU_PORT                               internal static fixed bin(17,0)          initial dcl 2-176
CRASH_INITIALIZATION                   internal static fixed bin(17,0)          initial dcl 1-18
IOM_PORT                               internal static fixed bin(17,0)          initial dcl 2-176
RE_EARLY_INITIALIZATION                internal static fixed bin(17,0)          initial dcl 1-19
SHUT_INITIALIZATION                    internal static fixed bin(17,0)          initial dcl 1-21
l68_core_ptw                           based           structure                level 1 dcl 3-4
l68_null_disk_ptw                      based           structure                level 1 dcl 3-15
l68_real_disk_ptw                      based           structure                level 1 dcl 3-14
l68_special_ptw                        based           structure                level 1 dcl 3-13
rcerr_addcpu_amoff                     internal static fixed bin(17,0)          initial dcl 4-16
rcerr_addcpu_bad_switches              internal static fixed bin(17,0)          initial dcl 4-16
rcerr_addcpu_enable                    internal static fixed bin(17,0)          initial dcl 4-16
rcerr_addcpu_gcos                      internal static fixed bin(17,0)          initial dcl 4-16
rcerr_addcpu_lockup                    internal static fixed bin(17,0)          initial dcl 4-16
rcerr_addcpu_no_response               internal static fixed bin(17,0)          initial dcl 4-16
rcerr_addcpu_startup                   internal static fixed bin(17,0)          initial dcl 4-16
rcerr_addcpu_trouble                   internal static fixed bin(17,0)          initial dcl 4-16
rcerr_addscu_enable                    internal static fixed bin(17,0)          initial dcl 4-31
rcerr_addscu_fault                     internal static fixed bin(17,0)          initial dcl 4-31
rcerr_addscu_switches                  internal static fixed bin(17,0)          initial dcl 4-31
rcerr_delcpu_last                      internal static fixed bin(17,0)          initial dcl 4-26
rcerr_delcpu_no_good_blcpu             internal static fixed bin(17,0)          initial dcl 4-26
rcerr_delcpu_no_stop                   internal static fixed bin(17,0)          initial dcl 4-26
rcerr_delmain_abs_wired                internal static fixed bin(17,0)          initial dcl 4-44
rcerr_delmain_nomem                    internal static fixed bin(17,0)          initial dcl 4-44
rcerr_isolts_bad_switches              internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_bootload_scu              internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_cpu_online                internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_illegal_cpu               internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_illegal_scu               internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_lda_fail                  internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_locked                    internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_no_config                 internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_no_mask                   internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_no_response               internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_no_str_flt                internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_not                       internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_scu_not                   internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_two_scu                   internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_wrong_cell                internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_wrong_scu                 internal static fixed bin(17,0)          initial dcl 4-57
rcerr_isolts_wrong_scu_cell            internal static fixed bin(17,0)          initial dcl 4-57
rcerr_locked                           internal static fixed bin(17,0)          initial dcl 4-48
rcerr_no_config                        internal static fixed bin(17,0)          initial dcl 4-48
rcerr_not_online                       internal static fixed bin(17,0)          initial dcl 4-48
rcerr_online                           internal static fixed bin(17,0)          initial dcl 4-48
rcerr_range                            internal static fixed bin(17,0)          initial dcl 4-48
rcerr_sprq_failed                      internal static fixed bin(17,0)          initial dcl 4-48
scs$bos_processor_tag                  external static fixed bin(3,0)           dcl 2-137
scs$bos_restart_flags                  external static bit(8)                   dcl 2-135
scs$cam_pair                           external static fixed bin(71,0)          dcl 2-103
scs$cam_wait                           external static bit(8)                   dcl 2-104
scs$cfg_data                           external static fixed bin(71,0)          array dcl 2-150
scs$cfg_data_save                      external static fixed bin(71,0)          dcl 2-152
scs$connect_lock                       external static bit(36)                  dcl 2-132
scs$cow                                external static structure                array level 1 dcl 2-65
scs$cow_ptrs                           external static structure                array level 1 dcl 2-77
scs$cpu_test_mask                      external static bit(72)                  dcl 2-96
scs$cpu_test_pattern                   external static bit(36)                  dcl 2-99
scs$cycle_priority_template            external static bit(7)                   dcl 2-172
scs$fast_cam_pending                   external static bit(36)                  array dcl 2-140
scs$faults_initialized                 external static bit(1)                   dcl 2-138
scs$idle_aptep                         external static pointer                  array packed unaligned dcl 2-130
scs$interrupt_controller               external static fixed bin(3,0)           dcl 2-141
scs$mask_ptr                           external static pointer                  array packed unaligned dcl 2-110
scs$nprocessors                        external static fixed bin(17,0)          dcl 2-136
scs$number_of_masks                    external static fixed bin(17,0)          dcl 2-97
scs$open_level                         external static bit(72)                  dcl 2-94
scs$port_addressing_word               external static bit(3)                   array dcl 2-148
scs$port_data                          external static structure                array level 1 dcl 2-56
scs$processor                          external static bit(8)                   dcl 2-143
scs$processor_data_switch_value        external static bit(36)                  dcl 2-162
scs$processor_start_int_no             external static fixed bin(5,0)           dcl 2-142
scs$processor_start_mask               external static bit(72)                  dcl 2-95
scs$processor_start_pattern            external static bit(36)                  dcl 2-98
scs$processor_start_wait               external static bit(8)                   dcl 2-144
scs$processor_switch_compare           external static bit(36)                  array dcl 2-159
scs$processor_switch_data              external static bit(36)                  array dcl 2-157
scs$processor_switch_mask              external static bit(36)                  array dcl 2-160
scs$processor_switch_template          external static bit(36)                  array dcl 2-158
scs$processor_test_data                external static structure                level 1 dcl 2-114
scs$read_mask                          external static bit(36)                  array dcl 2-109
scs$reconfig_general_cow               external static structure                level 1 dcl 2-82
scs$reconfig_lock                      external static bit(36)                  dcl 2-133
scs$reconfig_locker_id                 external static char(32)                 dcl 2-167
scs$set_cycle_switches                 external static bit(1)                   dcl 2-173
scs$set_mask                           external static bit(36)                  array dcl 2-108
scs$sys_level                          external static bit(72)                  dcl 2-93
scs$sys_trouble_pending                external static bit(1)                   dcl 2-139
scs$trouble_dbrs                       automatic       fixed bin(71,0)          array dcl 2-146
scs$trouble_flags                      external static bit(8)                   dcl 2-134
switch_w1                              based           structure                level 1 dcl 4-76

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_RETURN                    000656 constant        label                    dcl 183 ref 209
NEXT_CPU_LOOP                   000577 constant        label                    dcl 169 ref 146
final_scu                       000662 constant        entry                    external dcl 187 ref 204
init_error                      000705 constant        entry                    internal dcl 198 ref 79 82 85 88 118 133 159 166 172
init_scu                        000043 constant        entry                    external dcl 11
reset_scas_ptw                  000744 constant        entry                    internal dcl 231 ref 192
set_scas_ptw                    000724 constant        entry                    internal dcl 214 ref 70 93 97 101

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1250        1314    1072        1260
Length      1570    1072        44         237     155          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
init_scu                            148 external procedure  is an external procedure.  
init_error                              internal procedure  shares stack frame of external procedure init_scu.  
set_scas_ptw                            internal procedure  shares stack frame of external procedure init_scu.  
reset_scas_ptw                          internal procedure  shares stack frame of external procedure init_scu.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 tag_letter                  init_scu

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
init_scu                 000100 code                        init_scu
                         000101 tag                         init_scu
                         000102 ptp                         init_scu
                         000104 i                           init_scu
                         000105 j                           init_scu
                         000106 x                           init_scu
                         000107 low_base                    init_scu
                         000110 high_base                   init_scu
                         000111 mem_size                    init_scu
                         000112 found                       init_scu
                         000113 unfound_mask                init_scu
                         000114 cdp                         init_scu
                         000116 pdp                         init_scu

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_in         call_ext_out_desc   call_ext_out        return_mac          ext_entry           index_bs_1_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
privileged_mode_ut$check_for_mem_overlap                    scr_util$read_cfg             scr_util$set_mask
syserr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
scs$controller_config_size    scs$controller_data           scs$expanded_ports            scs$processor_data
scs$scas_page_table           sys_info$collection_1_phase




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000037        67 000050        69 000053        70 000056        75 000066        77 000075        79 000106
     82 000115        85 000125        88 000134        93 000151        97 000204       101 000240       111 000276
    113 000322       114 000326       115 000334       118 000347       124 000354       127 000423       128 000431
    130 000440       133 000453       142 000460       144 000462       145 000467       146 000472       149 000475
    150 000476       151 000503       152 000512       153 000524       154 000527       155 000533       156 000535
    157 000553       159 000554       161 000556       163 000557       164 000563       166 000565       169 000577
    172 000601       176 000615       180 000653       181 000655       183 000656       187 000657       189 000667
    191 000672       192 000677       193 000701       195 000704       198 000705       204 000707       206 000715
    207 000721       209 000723       214 000724       220 000726       222 000732       223 000737       224 000741
    226 000743       231 000744       236 000746       238 000752       240 000754


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
