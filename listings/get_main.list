	COMPILATION LISTING OF SEGMENT get_main
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1028.0 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
       14 
       15 get_main:
       16      procedure (Segp, Size, Tsdw);
       17 
       18 /* *	Subroutine to provide a wired, contiguous buffer/working segment for its caller.
       19*   *	If this subroutine is called before paging is enabled (or at least before init_sst
       20*   *	is called) the buffer/working segment will be allocated from the storage between
       21*   *	the perm-wired segments and the paged segments. Otherwise pc_abs is called to
       22*   *	find the necessary storage.
       23*   *
       24*   *	If the SLTE for the specified segment indicates it is paged, the storage is
       25*   *	acquired fron that just below the paged segments, otherwise the storage
       26*   *	just after the wired segments is used.
       27*   *
       28*   *	call get_main (Segp, size, Tsdw);
       29*   *
       30*   *	1. Segp	       is a pointer to the segment wanted. (Input)
       31*   *
       32*   *	2. size	       is the size of the segment wanted (in words)
       33*   *		       The parameter is returned as the next higher 0 mod 1024 value. (Input/Ouput)
       34*   *
       35*   *	3. Tsdw	       is a returned SDW for the segment. It is up to the caller to place
       36*   *		       this SDW in the descriptor segment. (Output)
       37*   *
       38*   *	Last Modified (date and reason):
       39*   *
       40*   *	01/27/76, S. Webber (Initial coding)
       41*   *	05/17/76, N. Morris for 28-5 compatibility
       42*   *	11/08/80, W. Olin Sibert, to zero storage before returning
       43*   August 1981	C. Hornig for new pc_abs.
       44*   *	04/04/81, W. Olin Sibert, to use sdw_util
       45*   *	September 1983, Keith Loepere, for paged wired segment.
       46**/
       47 
       48 dcl  Segp pointer parameter;
       49 dcl  Size fixed bin (18) parameter;
       50 dcl  Memory_address fixed bin (26) parameter;
       51 dcl  Tsdw fixed bin (71) parameter;
       52 
       53 dcl  cl fixed bin (9);
       54 dcl  code fixed bin (35);
       55 dcl  ptp ptr;
       56 dcl  astep ptr;
       57 dcl  segno fixed bin (18);
       58 dcl  save_sdw fixed bin (71);				/* For keeping the SDW until we're done clearing the seg */
       59 dcl  memory_address fixed bin (26);
       60 dcl  page_no fixed bin;
       61 dcl  size fixed bin (18);
       62 dcl  size_mod_1024 fixed bin (18, -10);
       63 
       64 dcl  1 sdwi aligned like sdw_info automatic;
       65 
       66 dcl  dseg$ (0:1023) fixed bin (71) external static;
       67 dcl  int_unpaged_page_tables$ external static;
       68 dcl  slt$ fixed bin external static;
       69 dcl  unpaged_page_tables$ external static;
       70 
       71 dcl  absadr entry (ptr, fixed bin (35)) returns (fixed bin (26));
       72 dcl  make_sdw$unthreaded entry (fixed bin (18), fixed bin (71), ptr, ptr);
       73 dcl  ptw_util_$make_core entry (ptr, fixed bin (26));
       74 dcl  pc_abs$wire_abs_contig entry (ptr, fixed bin (9), fixed bin (9), fixed bin (35));
       75 dcl  privileged_mode_ut$swap_sdw entry (ptr, ptr);
       76 dcl  sdw_util_$construct entry (pointer, pointer);
       77 dcl  sdw_util_$set_access entry (pointer, bit (4) unaligned);
       78 dcl  syserr entry options (variable);
       79 dcl  syserr$error_code entry options (variable);
       80 
       81 dcl  (addr, addrel, baseno, bin, bit, divide, mod, null, string) builtin;
       82 
       83 
       84 	segno = bin (baseno (Segp), 18);
       85 	sltp = addr (slt$);
       86 	sltep = addr (slt.seg (segno));
       87 
       88 	size_mod_1024 = fixed (Size + 1023, 18, -10);
       89 	size = size_mod_1024;			/* variables have different precisions */
       90 
       91 	slte_uns.bit_count = size * 36;
       92 	cl = divide (size_mod_1024, 1024, 18, 0);
       93 	slte_uns.cur_length = cl;
       94 
       95 	if slt.free_core_start = 0 then do;		/* must call pc_contig */
       96 	     call make_sdw$unthreaded (segno, Tsdw, astep, ptp);
       97 	     call pc_abs$wire_abs_contig (astep, 0, cl, code);
       98 	     if code ^= 0
       99 	     then
      100 no_room:
      101 		do;
      102 		     namep = addrel (slt.name_seg_ptr, slte.names_ptr);
      103 		     call syserr$error_code (CRASH, code, "get_main: Insufficient storage available for ^a",
      104 			segnam.names (1).name);
      105 		end;
      106 
      107 	     call privileged_mode_ut$swap_sdw (Segp, addr (Tsdw));
      108 	     return;				/* All done for the after-init_sst case */
      109 	     end;
      110 
      111 /* Check for no more room */
      112 
      113 	if slt.free_core_size < size then do;
      114 	     code = 0;
      115 	     go to no_room;
      116 	     end;
      117 
      118 	if slte.paged
      119 	then memory_address = slt.free_core_start + slt.free_core_size - size;
      120 	else do;
      121 	     memory_address = slt.free_core_start;
      122 	     slt.free_core_start = slt.free_core_start + size;
      123 	     end;
      124 	slt.free_core_size = slt.free_core_size - size;
      125 
      126 generate:
      127 	if slte.paged
      128 	then upt_ptr = addr (int_unpaged_page_tables$);		/* seg will get real page table when make_segs_paged is run */
      129 	else upt_ptr = addr (unpaged_page_tables$);
      130 
      131 /* Now fill in SDW */
      132 
      133 	unspec (sdwi) = ""b;			/* Prepare to call sdw_util to build the SDW */
      134 	string (sdwi.access) = "1010"b;		/* Start out with RW access for clearing */
      135 	sdwi.size = size;				/* Segment is unpaged by default */
      136 
      137 	sdwi.flags.paged = "1"b;
      138 	upt_entry_ptr = ptr (upt_ptr, upt.current_length);
      139 	upt.current_length = upt.current_length + 2 + round (cl, -1);
      140 	if upt.current_length > upt.max_length then do;
      141 	     namep = addrel (slt.name_seg_ptr, slte.names_ptr);
      142 	     call syserr (CRASH, "get_main: not enough room to allocate unpaged page table for ^a.", segnam.names (1).name);
      143 	end;
      144 	upt_entry.size = cl;
      145 	upt_entry.segno = segno;
      146 	do page_no = 1 to cl;
      147 	     call ptw_util_$make_core (addr (upt_entry.ptws (page_no)), memory_address);
      148 	     memory_address = memory_address + 1024;
      149 	end;
      150 
      151 	sdwi.address = absadr (addr (upt_entry.ptws), (0));
      152 	call sdw_util_$construct (addr (Tsdw), addr (sdwi));
      153 						/* Make an SDW */
      154 
      155 	save_sdw = dseg$ (segno);			/* Save the current SDW for this segment */
      156 	call privileged_mode_ut$swap_sdw (Segp, addr (Tsdw));
      157 						/* and prepare to zero the segment */
      158 
      159 /* Even though memory is supposed to be clear, some of the "allocate-free"
      160*   tricks used for firmware may leave gruft around. */
      161 
      162 	begin;
      163 declare  segment_overlay (size) bit (36) aligned based (Segp);
      164 	     segment_overlay = ""b;
      165 	end;
      166 
      167 	call sdw_util_$set_access (addr (Tsdw), slte.access);
      168 						/* Set the real access */
      169 
      170 	call privileged_mode_ut$swap_sdw (Segp, addr (save_sdw));
      171 						/* and replace it with what was there before */
      172 
      173 	return;					/* Our caller will actually swap in the new SDW */
      174 						/* when it is needed; some callers require both for a while */
      175 
      176 given_address: entry (Segp, Memory_address, Size, Tsdw);
      177 
      178 /* Construct a memory segment as above, but use callers memory address. */
      179 
      180 	segno = bin (baseno (Segp), 18);
      181 	sltp = addr (slt$);
      182 	sltep = addr (slt.seg (segno));
      183 
      184 	size_mod_1024 = fixed (Size + 1023, 18, -10);
      185 	size = size_mod_1024;			/* variables have different precisions */
      186 
      187 	slte_uns.bit_count = size * 36;
      188 	cl = divide (size_mod_1024, 1024, 18, 0);
      189 	slte_uns.cur_length = cl;
      190 
      191 	memory_address = Memory_address;
      192 	go to generate;
      193 /* format: off */
      194  /* BEGIN INCLUDE FILE slt.incl.pl1 --- Last modified 2/76 SHW */
  1     2 
  1     3 /* Declarations for Segment Loading Table header and array.
  1     4*
  1     5*   Used by Initialization and MST Checker subroutines */
  1     6 
  1     7 dcl sltp ptr,					/* pointer to base of SLT segment */
  1     8     names_ptr ptr,					/* pointer to base of SLT names segment */
  1     9     namep ptr,					/* pointer to segment name list block */
  1    10     pathp ptr,					/* pointer to segment's directory path name */
  1    11     aclp ptr;					/* pointer to acl structure */
  1    12 
  1    13 declare 1 slt based (sltp) aligned,			/* declaration of Segment Loading Table (SLT) */
  1    14 	2 name_seg_ptr ptr,				/* words 0-1, pointer (ITS pair) to name segment */
  1    15 	2 free_core_start fixed bin (24),		/* word 2, start of free core after perm-wired */
  1    16 	2 first_sup_seg fixed bin (18),		/* word 3, first supervisor segment number */
  1    17 	2 last_sup_seg fixed bin (18), 		/* word 4, last supervisor segment number */
  1    18 	2 first_init_seg fixed bin (18),		/* word 5, first initializer segment number */
  1    19 	2 last_init_seg fixed bin (18),		/* word 6, last initializer segment number */
  1    20 	2 free_core_size fixed bin (24),		/* size (in words) of free core after perm-wired */
  1    21 	2 seg (0:8191) aligned,			/* segment entries (4 words each) */
  1    22 	  3 slte (4) fixed bin (35);			/* Space for SLT entries */
  1    23 
  1    24 /* auxiliary segment of SLT for storing of segment names and directory path names */
  1    25 
  1    26 declare 1 name_seg based (names_ptr) aligned,		/* name segment header */
  1    27 	2 pad bit (18) unal,
  1    28 	2 next_loc bit (18) unal,			/* Next available free location in name seg */
  1    29 	2 ht (0:127) bit (18) aligned;		/* Names hash table */
  1    30 
  1    31 declare 1 segnam based (namep) aligned,			/* declaration for segment name block */
  1    32 	2 count fixed bin (17),			/* number of segment names in this block */
  1    33 	2 names (50 refer (segnam.count)),		/* segment name array */
  1    34 	  3 hp bit (18) unal,			/* hash thread pointer */
  1    35 	  3 ref bit (1) unal,			/* "1"b if name referenced */
  1    36 	  3 pad bit (5) unal,
  1    37 	  3 segno bit (12) unal,			/* segment number associated with this name */
  1    38 	  3 name char (32) unal;			/* space for name (max 32 characters) */
  1    39 
  1    40 declare 1 path based (pathp) aligned,			/* declaration for directory path name */
  1    41 	2 size fixed bin (17),			/* length of pathname */
  1    42 	2 name char (168 refer (path.size)) unal,	/* directory path name */
  1    43 	2 acls fixed bin;				/* ACL list starts here */
  1    44 
  1    45 declare 1 acls based (aclp) aligned,			/* declaration for acl list */
  1    46 	2 count fixed bin,				/* number of entries in acl list */
  1    47 	2 acl (50 refer (acls.count)),		/* array of acl entries */
  1    48 	  3 userid char (32),			/* user specification */
  1    49 	  3 mode bit (36) aligned,			/* mode for the specified user */
  1    50 	  3 pad bit (36) aligned,
  1    51 	  3 code fixed bin;
  1    52 
  1    53 
  1    54 /* END INCLUDE FILE slt.incl.pl1 */
      194 
      195  /* BEGIN INCLUDE FILE slte.incl.pl1 */
  2     2 /* Declaration for Segment Loading Table Entry structure.
  2     3*   Used by Initialization, MST Generation, and MST Checker subroutines */
  2     4 /* modified 5/4/76 by Noel I. Morris	*/
  2     5 /* last modified 12/12/83 by Keith Loepere for breakpointable */
  2     6 /* format: style3 */
  2     7 
  2     8 dcl	sltep		ptr;
  2     9 
  2    10 dcl	1 slte_uns	based (sltep) aligned,
  2    11 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  2    12 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  2    13 /**** End of word 1 */
  2    14 	  2 access	bit (4),			/* SDW access bit (REWP) */
  2    15 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  2    16 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  2    17 	  2 firmware_seg	bit (1),			/* load in low 256 */
  2    18 	  2 layout_seg	bit (1),			/* mailbox & such */
  2    19 	  2 breakpointable  bit (1),			/* includes breakpoint_page */
  2    20 	  2 pad1		bit (3),			/* unused */
  2    21 	  2 wired		bit (1),			/* segment is wired if ON */
  2    22 	  2 paged		bit (1),			/* segment is paged if ON */
  2    23 	  2 per_process	bit (1),			/* segment is per-process if ON */
  2    24 	  2 pad3		bit (2),
  2    25 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  2    26 /**** End of 1st half of word 2 */
  2    27 	  2 pad4		bit (3),
  2    28 	  2 branch_required bit (1),			/* path name supplied if ON */
  2    29 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  2    30 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  2    31 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  2    32 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  2    33 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  2    34 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  2    35 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  2    36 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  2    37 /***** End of word 2 */
  2    38 	  2 pad5		bit (6),
  2    39 	  2 cur_length	fixed bin (9) uns,		/* current length of segment (in 1024 word blocks) */
  2    40 	  2 ringbrack	(3) fixed bin (3) uns,	/* ringbrackets */
  2    41 	  2 segno		fixed bin (18) uns,		/* text/link segment number */
  2    42 /***** End of word 3 */
  2    43 	  2 pad7		bit (3),
  2    44 	  2 max_length	fixed bin (9) uns,		/* maximum length for segment */
  2    45 	  2 bit_count	fixed bin (24) uns
  2    46 	  )		unaligned;		/* bitcount of segment */
  2    47 
  2    48 dcl	1 slte		based (sltep) aligned,
  2    49 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  2    50 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  2    51 	  2 access	bit (4),			/* SDW access bit (REWP) */
  2    52 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  2    53 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  2    54 	  2 firmware_seg    bit (1),
  2    55 	  2 layout_seg      bit (1),
  2    56 	  2 breakpointable  bit (1),
  2    57 	  2 pad2		bit (3),
  2    58 	  2 wired		bit (1),			/* segment is wired if ON */
  2    59 	  2 paged		bit (1),			/* segment is paged if ON */
  2    60 	  2 per_process	bit (1),			/* segment is per-process if ON */
  2    61 	  2 pad3		bit (2),
  2    62 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  2    63 	  2 pad4		bit (3),
  2    64 	  2 branch_required bit (1),			/* path name supplied if ON */
  2    65 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  2    66 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  2    67 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  2    68 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  2    69 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  2    70 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  2    71 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  2    72 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  2    73 	  2 pad5		bit (6),
  2    74 	  2 cur_length	bit (9),			/* current length of segment (in 1024 word blocks) */
  2    75 	  2 ringbrack	(3) bit (3),		/* ringbrackets */
  2    76 	  2 segno		bit (18),			/* text/link segment number */
  2    77 	  2 pad6		bit (3),
  2    78 	  2 max_length	bit (9),			/* maximum length for segment */
  2    79 	  2 bit_count	bit (24)
  2    80 	  )		unaligned;		/* bitcount of segment */
  2    81 
  2    82 /* END INCLUDE FILE slte.incl.pl1 */
      195 
      196  /* BEGIN INCLUDE FILE ... sdw_info.incl.pl1 ... 12/16/80, for ADP conversion */
  3     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  3     3 
  3     4 dcl  sdw_info_ptr pointer;
  3     5 
  3     6 dcl 1 sdw_info aligned based (sdw_info_ptr),		/* Structure describing SDW contents */
  3     7     2 address fixed bin (26), 			/* Address of seg base or of page table */
  3     8     2 size fixed bin (19),				/* Max length of segment (NOT offset of last word) */
  3     9 
  3    10     2 access unaligned,				/* REWP */
  3    11       3 read bit (1) unaligned,
  3    12       3 execute bit (1) unaligned,
  3    13       3 write bit (1) unaligned,
  3    14       3 privileged bit (1) unaligned,
  3    15 
  3    16     2 pad1 bit (32) unaligned,
  3    17 
  3    18     2 rings unaligned,				/* Ring brackets */
  3    19       3 r1 bit (3) unaligned,
  3    20       3 r2 bit (3) unaligned,
  3    21       3 r3 bit (3) unaligned,
  3    22 
  3    23     2 pad2 bit (27) unaligned,
  3    24 
  3    25     2 flags aligned,
  3    26       3 paged bit (1) unaligned,			/* "1"b => Segment is paged */
  3    27       3 faulted bit (1) unaligned,			/* "1"b => SDW has fault set */
  3    28       3 cache bit (1) unaligned,			/* "1"b => Segment is encacheable */
  3    29       3 pad3 bit (33) unaligned,
  3    30 
  3    31     2 gate_entry_bound fixed bin (14);			/* Number of entrypoints in gate, or zero */
  3    32 
  3    33 /* END INCLUDE FILE ... sdw_info.incl.pl1 */
      196 
      197  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  4     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  4     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  4     4 
  4     5 /* This include file has an ALM version.  Keep 'em in sync! */
  4     6 
  4     7 dcl (
  4     8 
  4     9 /* The following constants define the message action codes.  This indicates
  4    10*how a message is to be handled.  */
  4    11 
  4    12      SYSERR_CRASH_SYSTEM	init (1),			
  4    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  4    14 
  4    15      SYSERR_TERMINATE_PROCESS	init (2),
  4    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  4    17 
  4    18      SYSERR_PRINT_WITH_ALARM	init (3),
  4    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  4    20 
  4    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  4    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  4    23 
  4    24      SYSERR_LOG_OR_PRINT	init (4),
  4    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  4    26 
  4    27      SYSERR_LOG_OR_DISCARD	init (5),
  4    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  4    29 
  4    30 
  4    31 /* The following constants are added to the normal severities to indicate
  4    32*different sorting classes of messages.  */
  4    33 
  4    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  4    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  4    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  4    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  4    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  4    39 	) fixed bin internal static options (constant);
  4    40 
  4    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      197 
      198  /* BEGIN include file unpaged_page_tables.incl.pl1 */
  5     2 
  5     3 /* This include file describes the segments unpaged_page_tables and
  5     4*int_unpaged_page_tables.  These segments contain the page tables for
  5     5*segments that are paged and wired, those segments previously called
  5     6*unpaged.
  5     7*
  5     8*Written September 15, 1983 by Keith Loepere. */
  5     9 
  5    10 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  5    11 
  5    12 dcl  upt_ptr		        ptr;
  5    13 dcl  1 upt		        aligned based (upt_ptr),
  5    14        2 sst_absloc		        fixed bin (26),	/* for dump analyzers */
  5    15        2 sst_last_loc	        fixed bin (26),
  5    16        2 upt_absloc		        fixed bin (26),
  5    17        2 upt_last_loc	        fixed bin (26),
  5    18        2 iupt_absloc	        fixed bin (26),
  5    19        2 iupt_last_loc	        fixed bin (26),
  5    20 
  5    21        2 current_length	        fixed bin,		/* number of words currently used */
  5    22        2 max_length		        fixed bin,		/* max number of words in memory allocated */
  5    23        2 first_entry	        like upt_entry;
  5    24 
  5    25 dcl  upt_entry_ptr		        ptr;
  5    26 dcl  1 upt_entry		        aligned based (upt_entry_ptr),
  5    27        2 size		        fixed bin,		/* number of page table words allocated */
  5    28        2 segno		        fixed bin,		/* of hardcore segment */
  5    29        2 ptws		        (0 refer (upt_entry.size)) bit (36) aligned;
  5    30 
  5    31 /* END include file unpaged_page_tables.incl.pl1 */
      198 
      199 
      200 
      201 /* BEGIN MESSAGE DOCUMENTATION
      202*
      203*   Message:
      204*   get_main: insufficient storage available for NAME
      205*
      206*   S:	$crash
      207*
      208*   T:	$init
      209*
      210*   M:	Insufficient wired memory
      211*   was available to create the segment NAME during initialization.
      212*   The system tape may be bad, or the configuration may be too small,
      213*   or the system parameters specified in the configuration deck may be
      214*   incorrect or inconsistent with the amount of main storage available.
      215*
      216*   A:	$recover
      217*   Check the configuration and the CONFIG deck.
      218*   $boot_tape
      219*
      220*   Message:
      221*   get_main: not enough room to allocate unpaged page table for NAME.
      222*
      223*   S: $crash
      224*
      225*   T: $init
      226*
      227*   M: Either the segment unpaged_page_tables or int_unpaged_page_tables
      228*   was not big enough so as to have the page table for segment NAME allocated
      229*   within it.  The system tape may be bad, or changes made to the mst require 
      230*   bigger unpaged page tables.
      231*
      232*   A: $recover
      233*   Try another tape.  If bigger unpaged page tables are in order, a change
      234*   must be made to bootload_equs.incl.alm and collection 0 recompiled.
      235*   $boot_tape
      236*
      237*   END MESSAGE DOCUMENTATION */
      238 
      239      end get_main;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0825.5  get_main.pl1                      >special_ldd>install>MR12.3-1114>get_main.pl1
194          1    05/24/82  1005.0  slt.incl.pl1                      >ldd>include>slt.incl.pl1
195          2    07/11/84  0937.3  slte.incl.pl1                     >ldd>include>slte.incl.pl1
196          3    03/27/82  0430.3  sdw_info.incl.pl1                 >ldd>include>sdw_info.incl.pl1
197          4    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
198          5    07/11/84  0937.3  unpaged_page_tables.incl.pl1      >ldd>include>unpaged_page_tables.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CRASH                           000010 constant        fixed bin(17,0)          initial dcl 4-7 set ref 103* 142*
Memory_address                         parameter       fixed bin(26,0)          dcl 50 ref 176 191
Segp                                   parameter       pointer                  dcl 48 set ref 15 84 107* 156* 164 170* 176 180
Size                                   parameter       fixed bin(18,0)          dcl 49 ref 15 88 176 184
Tsdw                                   parameter       fixed bin(71,0)          dcl 51 set ref 15 96* 107 107 152 152 156 156 167
                                                                                  167 176
absadr                          000020 constant        entry                    external dcl 71 ref 151
access                    2     000116 automatic       structure                level 2 in structure "sdwi" packed packed unaligned
                                                                                  dcl 64 in procedure "get_main" set ref 134*
access                    1            based           bit(4)                   level 2 in structure "slte" packed packed unaligned
                                                                                  dcl 2-48 in procedure "get_main" set ref 167*
addr                                                   builtin function         dcl 81 ref 85 86 107 107 126 129 147 147 151 151 152
                                                                                  152 152 152 156 156 167 167 170 170 181 182
addrel                                                 builtin function         dcl 81 ref 102 141
address                         000116 automatic       fixed bin(26,0)          level 2 dcl 64 set ref 151*
astep                           000104 automatic       pointer                  dcl 56 set ref 96* 97*
baseno                                                 builtin function         dcl 81 ref 84 180
bin                                                    builtin function         dcl 81 ref 84 180
bit_count                 3(12)        based           fixed bin(24,0)          level 2 packed packed unsigned unaligned dcl 2-10
                                                                                  set ref 91* 187*
cl                              000100 automatic       fixed bin(9,0)           dcl 53 set ref 92* 93 97* 139 144 146 188* 189
code                            000101 automatic       fixed bin(35,0)          dcl 54 set ref 97* 98 103* 114*
cur_length                2            based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 2-10
                                                                                  set ref 93* 189*
current_length            6            based           fixed bin(17,0)          level 2 dcl 5-13 set ref 138 139* 139 140
divide                                                 builtin function         dcl 81 ref 92 188
dseg$                           000010 external static fixed bin(71,0)          array dcl 66 ref 155
flags                     4     000116 automatic       structure                level 2 dcl 64
free_core_size            7            based           fixed bin(24,0)          level 2 dcl 1-13 set ref 113 118 124* 124
free_core_start           2            based           fixed bin(24,0)          level 2 dcl 1-13 set ref 95 118 121 122* 122
int_unpaged_page_tables$        000012 external static fixed bin(17,0)          dcl 67 set ref 126
make_sdw$unthreaded             000022 constant        entry                    external dcl 72 ref 96
max_length                7            based           fixed bin(17,0)          level 2 dcl 5-13 ref 140
memory_address                  000112 automatic       fixed bin(26,0)          dcl 59 set ref 118* 121* 147* 148* 148 191*
name                      2            based           char(32)                 array level 3 packed packed unaligned dcl 1-31 set
                                                                                  ref 103* 142*
name_seg_ptr                           based           pointer                  level 2 dcl 1-13 ref 102 141
namep                           000126 automatic       pointer                  dcl 1-7 set ref 102* 103 141* 142
names                     1            based           structure                array level 2 dcl 1-31
names_ptr                              based           bit(18)                  level 2 packed packed unaligned dcl 2-48 ref 102 141
page_no                         000113 automatic       fixed bin(17,0)          dcl 60 set ref 146* 147 147*
paged                     4     000116 automatic       bit(1)                   level 3 in structure "sdwi" packed packed unaligned
                                                                                  dcl 64 in procedure "get_main" set ref 137*
paged                     1(13)        based           bit(1)                   level 2 in structure "slte" packed packed unaligned
                                                                                  dcl 2-48 in procedure "get_main" ref 118 126
pc_abs$wire_abs_contig          000026 constant        entry                    external dcl 74 ref 97
privileged_mode_ut$swap_sdw     000030 constant        entry                    external dcl 75 ref 107 156 170
ptp                             000102 automatic       pointer                  dcl 55 set ref 96*
ptw_util_$make_core             000024 constant        entry                    external dcl 73 ref 147
ptws                      2            based           bit(36)                  array level 2 dcl 5-26 set ref 147 147 151 151
save_sdw                        000110 automatic       fixed bin(71,0)          dcl 58 set ref 155* 170 170
sdw_info                               based           structure                level 1 dcl 3-6
sdw_util_$construct             000032 constant        entry                    external dcl 76 ref 152
sdw_util_$set_access            000034 constant        entry                    external dcl 77 ref 167
sdwi                            000116 automatic       structure                level 1 dcl 64 set ref 133* 152 152
seg                      10            based           structure                array level 2 dcl 1-13 set ref 86 182
segment_overlay                        based           bit(36)                  array dcl 163 set ref 164*
segnam                                 based           structure                level 1 dcl 1-31
segno                           000106 automatic       fixed bin(18,0)          dcl 57 in procedure "get_main" set ref 84* 86 96*
                                                                                  145 155 180* 182
segno                     1            based           fixed bin(17,0)          level 2 in structure "upt_entry" dcl 5-26
                                                                                  in procedure "get_main" set ref 145*
size                      1     000116 automatic       fixed bin(19,0)          level 2 in structure "sdwi" dcl 64 in procedure
                                                                                  "get_main" set ref 135*
size                                   based           fixed bin(17,0)          level 2 in structure "upt_entry" dcl 5-26
                                                                                  in procedure "get_main" set ref 144*
size                            000114 automatic       fixed bin(18,0)          dcl 61 in procedure "get_main" set ref 89* 91 113
                                                                                  118 122 124 135 164 185* 187
size_mod_1024                   000115 automatic       fixed bin(18,-10)        dcl 62 set ref 88* 89 92 184* 185 188
slt                                    based           structure                level 1 dcl 1-13
slt$                            000014 external static fixed bin(17,0)          dcl 68 set ref 85 181
slte                                   based           structure                level 1 dcl 2-48
slte_uns                               based           structure                level 1 dcl 2-10
sltep                           000130 automatic       pointer                  dcl 2-8 set ref 86* 91 93 102 118 126 141 167 182*
                                                                                  187 189
sltp                            000124 automatic       pointer                  dcl 1-7 set ref 85* 86 95 102 113 118 118 121 122
                                                                                  122 124 124 141 181* 182
string                                                 builtin function         dcl 81 set ref 134*
syserr                          000036 constant        entry                    external dcl 78 ref 142
syserr$error_code               000040 constant        entry                    external dcl 79 ref 103
unpaged_page_tables$            000016 external static fixed bin(17,0)          dcl 69 set ref 129
upt                                    based           structure                level 1 dcl 5-13
upt_entry                              based           structure                level 1 dcl 5-26
upt_entry_ptr                   000134 automatic       pointer                  dcl 5-25 set ref 138* 144 145 147 147 151 151
upt_ptr                         000132 automatic       pointer                  dcl 5-12 set ref 126* 129* 138 138 139 139 140 140

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 4-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 4-7
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 4-7
LOG                                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 4-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 4-7
aclp                                   automatic       pointer                  dcl 1-7
acls                                   based           structure                level 1 dcl 1-45
bit                                                    builtin function         dcl 81
mod                                                    builtin function         dcl 81
name_seg                               based           structure                level 1 dcl 1-26
names_ptr                              automatic       pointer                  dcl 1-7
null                                                   builtin function         dcl 81
path                                   based           structure                level 1 dcl 1-40
pathp                                  automatic       pointer                  dcl 1-7
sdw_info_ptr                           automatic       pointer                  dcl 3-4

NAMES DECLARED BY EXPLICIT CONTEXT.
generate                        000255 constant        label                    dcl 126 ref 192
get_main                        000052 constant        entry                    external dcl 15
given_address                   000537 constant        entry                    external dcl 176
no_room                         000155 constant        label                    dcl 98 ref 115

NAMES DECLARED BY CONTEXT OR IMPLICATION.
fixed                                                  builtin function         ref 88 184
ptr                                                    builtin function         ref 138
round                                                  builtin function         ref 139
unspec                                                 builtin function         ref 133

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1004        1046     612        1014
Length      1340     612        42         255     172           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get_main                            160 external procedure  is an external procedure.  
begin block on line 162                 begin block         shares stack frame of external procedure get_main.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
get_main                 000100 cl                          get_main
                         000101 code                        get_main
                         000102 ptp                         get_main
                         000104 astep                       get_main
                         000106 segno                       get_main
                         000110 save_sdw                    get_main
                         000112 memory_address              get_main
                         000113 page_no                     get_main
                         000114 size                        get_main
                         000115 size_mod_1024               get_main
                         000116 sdwi                        get_main
                         000124 sltp                        get_main
                         000126 namep                       get_main
                         000130 sltep                       get_main
                         000132 upt_ptr                     get_main
                         000134 upt_entry_ptr               get_main

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry           trunc_fx1           round_fx1
divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absadr                        make_sdw$unthreaded           pc_abs$wire_abs_contig        privileged_mode_ut$swap_sdw
ptw_util_$make_core           sdw_util_$construct           sdw_util_$set_access          syserr
syserr$error_code

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dseg$                         int_unpaged_page_tables$      slt$                          unpaged_page_tables$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     15 000046        84 000064        85 000072        86 000074        88 000077        89 000104        91 000106
     92 000110        93 000115        95 000117        96 000121        97 000135        98 000153       102 000155
    103 000163       107 000216       108 000232       113 000233       114 000236       115 000237       118 000240
    121 000247       122 000251       124 000253       126 000255       129 000265       133 000270       134 000273
    135 000277       137 000301       138 000303       139 000307       140 000320       141 000322       142 000330
    144 000355       145 000357       146 000362       147 000371       148 000405       149 000407       151 000411
    152 000430       155 000445       156 000452       164 000465       167 000501       170 000515       173 000531
    176 000532       180 000551       181 000560       182 000563       184 000566       185 000573       187 000575
    188 000577       189 000604       191 000606       192 000610


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
